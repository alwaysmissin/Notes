# Y86-64的顺序实现
## 将处理组织成阶段
- 各个阶段以及阶段内执行操作的简略描述：
	- **取指(fetch)**：
		- 取指阶段从内存读取指令字节，地址为程序PC的值
		- 从指令中取出指令指示符字节的**两个四位部分**：
			- icode指令代码
			- ifun指令功能
		- 它可能取出一个寄存器指示符字节，指明**一个或两个寄存器操作数指示符rA和rB**
		- 还可能取出一个四字节常数字valC
		- 并且，按照顺序方式计算当前指令的下一条指令地址valP
	- **译码(decode)**：
		- 译码阶段从寄存器文件读入最多两个操作数，得到值valA和/或valB
		- 通常，它读入指令**rA和rB字段指明的寄存器**，不过有些指令是读取**寄存器%rsp**的
	- **执行(execute)**：
		- 算数/逻辑单元（ALU）根据指令指明(ifun)的操作，执行指令指明的操作，计算内存引用的有效地址
		- 或增加或减少栈指针
		- 得到的值被称为**valE(xecute)**
		- 同时，可能设置条件码
	- **访存(memory)**：访存阶段可以将数据写入内存，或者从内存中读取出数据，读取出的值为**valM(emory)**
	- **写回(write back)**：写回阶段最多可以写两个结果到寄存器文件
	- **更新PC(PC update)**：将PC设置成下一条指令的地址
- 在简化的实现中，发生任何**异常**时，处理器就回停止：执行halt指令或非法指令，或它试图读写非法的地址
- 下面的图中描述了不同指令在各个阶段是如何处理的，表中的每一行都描述了一个信号或存储状态的分配：
![](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230115144232.png)
![](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230115144306.png)
![](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230115144319.png)
![](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230115144332.png)
- 对指令的跟踪执行
![](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230115144405.png)
![](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230115144420.png)
![](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230115144437.png)
![](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230115144521.png)
![](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230115144732.png)

## SEQ硬件结构
![](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230115144828.png)
- 硬件单元与各个处理阶段的相关性：
	- 取指：
		- 将程序计数器存储器作为地址，指令内存读取指令的字节，PC增加器计算valP
	- 译码：
		- 寄存器文件有两个读端口A和B，从这两个端口同时读取寄存器值valA和valB
	- 执行：
		- 执行阶段根据指令的类型，将ALU用于不同的目的
		- 对于整数操作，它要执行指令所制定的运算
		- 对于其他指令，他会作为一个加法器来计算增加或减少栈指针，或计算有效地址
		- 条件码寄存器有三个条件码位，ALU负责计算条件码的新值
			- 当执行条件传送指令时，根据条件码和传送条件来计算决定是否更新目标寄存器
			- 同样，当执行一条跳转指令时，会根据条件码和跳转类型来计算分值信号Cnd
	- 访存：
		- 数据内存读出或写入一个内存字
		- 指令和数据内存访问的是内存的相同位置，但是用于不同的目的
	- 写回：
		- 寄存器文件有两个写端口：
			- 端口E用来写ALU计算出来的值
			- 端口M用来写从数据内存中读出的值
	- PC更新：
		- valP：下一条指令的地址
		- valC：调用指令或跳转指令指定的目标地址
		- valM：从内存读取的返回地址
- 画图惯例：
	- 白色方框表示时钟寄存器
		- 程序计数器PC是SEQ中惟一的时钟寄存器
	- 浅蓝色方框表示硬件单元
		- 包括内存、ALU等等
	- **控制逻辑块**使用灰色圆角矩形表示
		- 这些块用一组信号源中进行选择，或者用来计算一些布尔函数
		- 是后续分析的重点
	- 线路的名字在白蒜圆圈中说明
	- 宽度为字长的数据连接用中等粗细的线表示
	- 宽度为字节或更窄的数据连接用细线表示
	- 单个位的连接用虚线来表示
![](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230115145627.png)


![](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230115145954.png)

## SEQ的时序

