# 虚拟化
## 进程
- **进程**: 运行中的程序
- 存在多个CPU的假象: 通过让一个进程只运行一个时间片, 然后切换到其他进程->**时分共享(time sharing)CPU技术**
- **上下文切换(context switch)**: 使操作系统停止一个程序. 并开始在给定的CPU上运行另一个程序
- **调度策略(scheduling policy)**: 利用历史信息以及性能指标来做出决定

### 抽象: 进程概念
- 进程的机器状态(machine state): 程序在运行时候可以读取或更新哪些内容?
	- 可以访问的内存
	- 寄存器

### 进程API
- 创建(create)
- 销毁(destroy): 销毁进程的接口
- 等待(wait): 等待进程停止运行
- 其他控制(miscellaneous control): 除了杀死或等待进程外的其他操作
- 状态(status): 获取有关进程的状态信息

### 进程创建: 更多细节
- 程序如何转化为进程?
	1. 将代码和所有静态数据加载到内存中, 加载到进程的地址空间上
	2. 为程序的运行时栈(run-time stack)分配内存
		- C语言中使用**栈存放局部变量, 函数参数和返回地址**
		- 也可能为程序的堆分配一些内存: C中, 堆用于存放显式请求的动态分配数据
	3. 其他的初始化任务, 特别是与IO相关的任务
		- 在UNIX系统中, 默认情况下每个进程都有3个打开的文件描述符, 用于标准输入、输出和错误
	4. 跳转到`main`开始执行

> [!note] 现代操作系统的懒加载
> 在早期的操作系统中, 加载过程尽早完成
> 现代操作系统惰性执行该过程, 即在程序执行期间需要加载的代码或数据片段, 才会加载
> 要理解代码和数据的惰性加载如何工作的, 需要了解分页和交换的机制

### 进程状态
- 进程的3种状态:
	- 运行(running): 进程在处理器上运行
	- 就绪(ready): 进程已经准备好运行, 但处于某些原因, 操作系统选择不在此时运行
	- 阻塞(blocked): 一个进程执行了某种操作, 直到发生其他事件才会准备运行
- 进程状态之间的转换:![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230922091621.png)
- 两个例子:![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230922091650.png)![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230922091701.png)

