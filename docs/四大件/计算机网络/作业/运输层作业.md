# 运输层作业
## 用自己的语言，总结传输层的作用、位置、主要功能和主要服务

- 传输层:
    
    - 作用: 为应用进程间的逻辑通信提供服务
        
        - 向应用层实体屏蔽了下面的网络核心中的细节, 使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道
            
    - 位置: 处于面向应用部分的最底层和面向通信部分的最高层
        
    - 主要功能
        
        - 对高层应用屏蔽了通信的细节, 无须果果考虑各种通信因素对网络通信过程本身的影响
            
        - 提供端到端之间的无差错保证, 弥补网络层提供服务的差异和不足
            
    - 主要服务
        
        - 面向连接的服务 **TCP** 服务
            
        - 面向无连接的服务 **UDP** 服务
            

## 在传输层中，端口、传输层地址和套接字分别是指什么？相互之间有什么关系？

- 端口: 用来**识别和区分**应用层的不同应用进程
    
- 传输层地址: 包括了**主机 IP 地址**和**端口号**
    
- 套接字: 是应用程序通过网络协议栈进行**通信的接口**, 是应用程序与网络协议栈进行**交互的接口**
    

- 端口、传输层地址和套接字之间的关系
    
    - 端口是套接字的一部分，用于标识应用程序或服务。
        
    - 传输层地址由 IP 地址和端口号组成，用于标识通信双方的地址信息。
        
    - 套接字由 IP 地址和端口号组成，用于表示一个网络通信的端点。
        

## 什么是 UDP 协议？有什么特点？

- UDP 协议: 为上层提供无连接的不可靠的数据传输服务
    
- 特点:
    
    - UDP 是无连接协议, 在发送数据之前不需要建立连接
        
    - UDP 使用尽量最大努力交付, 不保证可靠交付, 同时也不使用拥塞控制
        
    - UDP 是面向报文, 没有拥塞控制, 使用多媒体通信的要求
        
    - UDP 支持一对一、一对多、多对一和多对多的交互通信
        
    - UDP 的首部开销小, 只有 8 个字节
        

## 在 TCP 报文段的首部中，你认为哪些字段非常重要？原因是什么？

![image-20231117190144744](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo%2Fimage-20231117190144744.png)

- 源端口与目的端口
    
- 与实现**可靠传输**相关的字段:
    
    - 序列号: 用于指出**本 TCP 报文段数据载荷的第一个字节的序号**, 表示**我发送了什么**
        
    - 确认号: 用于**指出期望收到的下一个 TCP 报文段的数据载荷的第一个字节的序号**, 同时, 也是**对之前收到的数据的确认**, 表示**我想要什么**
        
    - ACK 确认标志位: 标志确认号字段是否有效
        
- 与实现**流量控制**相关的字段:
    
    - 窗口: 指出发送本文本段的一方的接收窗口的大小, 即接收缓存的可用空间大小, 用来表示**接收方的接收能力**
        
- 与数据校验相关的字段:
    
    - 检验和: 用于**差错检测**, 检测在传输的过程中是否出现了**误码**
        
- 与连接相关的字段:
    
    - 建立连接 SYN:
        
        - 当 `SYN == 1 && ACK == 0` 时候, 表明这是一个 TCP 连接请求报文段
            
        - 若对方同意建立连接, 则在响应的 TCP 报文段的首部中令 `SYN = 1 && ACK = 1`
            
    - 释放连接 FIN: 当 `FIN == 1` 时候, 表明此 TCP 报文段的发送方已经将全部的数据发送完毕, 现请求释放 TCP 连接
        
    - 复位 TCP 连接 RST: 当 `RST == 1` 时, 表明 TCP 连接出现严重差错, 必须释放连接, 然后重新建立连接
        

## 简述 TCP 连接建立和释放的基本过程

- TCP 连接建立过程
    
    - 发送 TCP 连接**请求报文段**, 进入同步已发送状态
        
        - TCP 连接请求报文段和 TCP 连接请求确认报文段中 `SYN=1`
            
        - 初始化 `seq=x`, 作为 TCP 客户进程所选择的初始序号
            
        - TCP 规定 SYN 被设置为 `1` 的报文段不能携带数据, 但是要消耗掉一个序号. 因此, TCP 客户进程下一次发送的 TCP 报文段的数据载荷的第一个字节序号为 `x+1`
            
    - 发送 TCP 连接**请求确认报文段,** 进入同步已接收状态
        
        - `SYN=1, ACK=1`
            
        - 同样初始化 `seq=y`, 作为 TCP 服务器进程所选择的初始序号
            
        - `ACK=x+1`, 是对 TCP 客户进程所选择的初始序号 `x` 的确认
            
    - 发送针对 TCP 连接请求确认报文段的普通 TCP 确认报文段, 进入连接已建立状态
        
- TCP 连接释放过程
    
    - 客户端发送 TCP 连接释放报文段, 并进入终止等待 `1` 状态
        
    - 服务器发送 TCP 普通确认报文段, 并进入关闭等待状态
        
        - 发送完毕后, 从客户进程到服务进程的连接就释放了, 此时 TCP 连接处于**半关闭状态**
            
            - TCP 客户进程已经没有数据要发送了, 但 TCP 服务器进程如果还有数据要发送, TCP 客户进程仍要接收
                
    - 服务器发送 TCP 连接释放报文段, 并进入最后确认状态
        
        - `FIN=1`
            
        - `ACK=u+1`, 进行重复确认
            
    - 客户端发送 TCP 普通确认报文段, 并进入时间等待状态
        
        - 等待 2 MSL (Maximum Segment Lifetime):
            
            - 为什么? 如果在客户端返回 TCP 普通确认报文段的过程中报文段丢失, 而此时客户端已经进入关闭状态的话, 由服务器发来的超时重传的 TCP 连接释放报文段无法被接收, **导致服务器一直处于无法关闭的状态**
                
    - 服务器**撤销**相应的传输控制块 TCB
        
    - 客户端**撤销**相应的传输控制块 TCB
        

## 在 TCP 中有哪些基本的计时器？这些计时器在 TCP 协议中各自发挥什么样的作用？

- **重传计时器 Retransmission Timer**: 当发送方发出数据报文后即启动该计时器, 在设定时间截至之前收到确认报文, 则传输成功, 撤销计时器; 否则, 传输失败, 重新发送数据报文
    
- **坚持计时器 Persistent Timer**: 坚持计时器是 TCP 协议中用于处理零窗口问题的一种机制，它定期发送坚持探测报文段给接收方，以保持连接的活动状态，并处理窗口大小为 0 的情况
    
    - 零窗口问题: 接收方接收缓冲区满时发送的窗口大小为 0 的 TCP 报文段
        
- **保活计时器 keepalive timer**: 判断两个 TCP 端点之间长久的连接是否正常
    

- **时间等待计时器 Time Wait Timer**: 为了能够正常关闭服务端的连接, 确保本次 TCP 连接中的所有报文都在连接断开前到达接收方, 防止本次连接中的报文进入下次连接中
    

## 什么是停止等待协议？为什么说在有流控的停止等待协议中可能会出现死锁？如何破除死锁？

- 停止等待协议: 发送方在发送每个数据包后会停止发送并等待接收方的确认（ACK），接收方在接收到数据包后会发送确认给发送方
    
- 死锁问题: 如果出现一下两种情况之一, 则可能出现死锁
    
    1. 数据报文丢失, 接收端等待数据报文, 发送端等待应答报文
        
    2. 应答报文丢失, 发送端等待应答报文, 接收端等待下一个数据报文
        
- 破除死锁的方法: 设置重传计时器, 在发出报文后的一定时间内还未收到应答报文, 则重新发送数据报文
    

## 什么是连续 ARQ 协议？为什么说连续 ARQ 协议可以大幅度的提高信道利用率？

- 连续 ARQ 协议: 发送方可以连续发送多个报文, 不必每发送完一个报文就停止并等待接收方的确认报文
    
- 连续 ARQ 协议使用了流水线的思想, 在等待应答报文的时候, 也可以发送数据报文, 即在 T_D + RTT + T_A 的时间内可以发送多个报文, 提高了信道利用率 (信道利用率 U 的计算方法 U=\frac{nT_D}{T_D + RTT + T_A})
    

## 什么是滑动窗口？举例说明其基本运行过程。

- 滑动窗口是一种流量控制的方法, 用于**约束发送方可以发送报文的数量**
    
- 发送方和接收方的窗口大小都设置为 3，表示发送方可以连续发送 3 个数据包给接收方，并且接收方可以接收并确认 3 个数据包。
    
    1. 发送方将文件分割成固定大小的数据包，并为每个数据包分配一个序号。假设文件总共有 9 个数据包。
        
    2. 发送方维护一个发送窗口，初始时起始位置是 0，结束位置是 2。
        
    3. 发送方将发送窗口内的前 3 个数据包（序号为 0、1、2）发送给接收方，并启动计时器开始计时。
        
    4. 接收方接收到数据包后，发送确认给发送方，并确认接收到的数据包的序号。
        
    5. 发送方接收到确认后，将发送窗口向前滑动，起始位置移动到确认的序号处（即 3 ），结束位置也相应地向前移动（即 5 ）。
        
    6. 发送方继续发送新的数据包（序号为 3、4、5），以填充发送窗口中的空闲位置。
        
    7. 接收方接收到数据包后，发送确认给发送方，并确认接收到的数据包的序号。
        
    8. 发送方接收到确认后，再次滑动发送窗口，起始位置移动到确认的序号处（即 6 ），结束位置相应地向前移动（即 8 ）。
        
    9. 发送方继续发送新的数据包（序号为 6、7、8）。
        
    10. 这个过程持续进行，直到发送方发送完所有的数据包并接收到最后一个数据包的确认。
        

## 在确定超时重传时间时，RTT、RTTs 和 RTTD 各自发挥着什么作用？

- RTT 用于确定 RTO (超时重传时间), 确定合适的 RTO, 对网络的整体利用率影响极大
    
- RTTs 用于反映往返时间, 可以得到一个比较平缓的往返时间, 减少单个 RTT 的抖动和噪声
    
- RTTD 用于衡量 RTT 的稳定性, 用于获得一个更稳定的 RTT 值, 以获得一个性能较优的 RTO 时间
    

## 什么是 RTO 的指数避退？有什么作用？

- RTO 的指数退避: 当超时而发生连续多次的重传时候, 在两次重传之前的超市与之的设置遵循"指数退避"的原则, 即当超时第一次重传后, 第二次重传的等待时间是第一次的 2 倍, 第三次重传的等待时间是第二次的 4 倍, 以此类推, 知道收到重传数据报的应答, RTO 退避因子恢复为 1
    
- 作用: 减小当网络处于无法快速交付数据报文状态时的网络负担
    

## 在 TCP 中，流量控制是怎么实现的？

- 流量控制的实现方法: 使用滑动窗口进行控制, 使发送方的发送速率不要太快, 纪要让接收方来得及接收, 也不使网络发生拥塞
    

## 简述慢启动和拥塞避免的基本概念

- **慢启动**: 在开始时设置拥塞窗口 `cwnd = 1`, 即一个最大报文段 MSS, 在没收到一个对新的报文段的确认后, 将拥塞窗口大小**翻一番**, 直到拥塞窗口大小到达了初始设置的**网络拥塞点**(ssthresh)时, 开始使用拥塞避免方法
    
- **拥塞避免**: 在慢启动时, 若拥塞窗口大小到达了初始设置的**网络拥塞点**(ssthresh)时, 在没收到一个对新的报文段的确认后, 将拥塞窗口 `+1`, 直到出现超时重传, 并重置拥塞窗口 cwnd, 将网络拥塞点减半