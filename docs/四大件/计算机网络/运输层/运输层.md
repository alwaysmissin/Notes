# 运输层
## 概述
> [!note] 
> 物理层, 数据链路层和网络层共同实现了主机到主机的通信.
> 但是在计算机网络中实际进行通信的实体, 是位于通信两端主机中的进程.
> 如何为运行在不同主机上的应用进程提供直接的逻辑通信服务, 就是运输层的主要任务.
> 因此运输层协议又被称为**端到端的协议.**
> ![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231107091706.png)
> ![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231107091751.png)
- #计网重点 运输层: 为应用进程间的逻辑通信提供服务
	- 向应用层实体屏蔽了下面网络核心的细节, 使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道
- #计网重点 运输层所处的位置: 面向应用部分的最底层, 面向通信部分的最高层
- 提供了两种不同的运输层协议 (服务): 
	- 面向连接的 TCP (Transmission Control Protocol)
		- 为上层提供**面向连接的可靠的**数据传输服务
		- 在传输数据之前, 必须**首先建立 TCP 连接**(逻辑连接, 而非物理连接); 数据传输结束后, 必须要**释放 TCP 连接**
		- **为了实现可靠传输所采用的措施**: 
			- TCP 管理连接
			- 确认机制
			- 超时重传
			- 流量控制
			- 拥塞控制
		- **实现复杂**, 报文段的**首部较大**, **占用的处理机资源较多**
	- 面向无连接的 UDP (User Datagram Protocol)
		- 为上层提供**无连接的不可靠**的数据传输服务
		- 传输数据前, 无须建立连接
		- 不需要实现可靠传输的各种机制
		- 实现简单, 首部较小
- 运输层使用端口号实现进程间的通信
	- 端口: ![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231107092835.png)
		- 熟知端口号 (0-1023): 由 IANA 分配给重要的应用协议
		- 登记端口号 (1024-49151): 需要进行登记, 以防重复
		- 短暂端口号 (49152-65535): 仅在客户端使用, 通信结束后释放
> [!note] 端口
> 端口号只具有本地意义, 只是为了标识本计算机网络协议栈应用层中的各应用程序.
> 在因特网中, 不同计算机中的相同端口号是没有关系的
> 另外, TCP 和 UDP 端口号之间也是没有关系的

> [!note] 访问过程
> ![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231107093401.png)

## TCP 与 UDP
- 连接过程: ![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231107093621.png)
	- TCP 需要先建立连接, 后数据传输, 再关闭连接
	- UDP 可以直接进行数据传输
- 对单播, 多播和广播的支持: 
	- TCP 只支持单播
	- UDP 支持单播, 多播和广播
- 应用层报文的处理: ![](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231107094112.png)
	- TCP 是面向字节流的
	- UDP 是面向应用报文的
- 对数据传输可靠性的支持情况:
	- TCP 会提供无差错的传输
	- UDP 不提供任何服务来实现无差错的传输
		- 如果出现丢失或误码的情况, 则直接丢弃
- 首部对比: ![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231107094400.png)
	- TCP: 20 Bytes - 60 Bytes
	- UDP: 8 Bytes

## 传输控制协议
### TCP 报文段的首部格式
- TCP 的全部功能实现都需要依赖其首部中的各种字段 ![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231107234306.png)
	- 端口字段: 源端口, 目的端口 
	- TCP 实现可靠传输的相关字段: 序号, 确认号, ACK
		- 序号: 
			- 32 bit
			- 用于指出**本 TCP 报文段数据载荷的第一个字节的序号**
			- 表示**我发了什么**
		- 确认号: 
			- 32 bit
			- 用来指出**期望收到**对方**下一个 TCP 报文段的数据载荷的第一个字节的序号**, 同时也是**对之前收到的所有数据的确认**
			- 表示**我想要什么**
		- 确认标志位 ACK: 
			- 只有当 `ACK==1` 时, 确认号字段才有效
			- 在 TCP 连接建立后, 所有传送的 TCP 报文段都必须把 ACK 置1
	- 指出 TCP 报文段首部的长度: 数据偏移
		- 4 bit, 计算时以 4 字节为单位 ($4byte \times offset$)
	- 流量控制: 窗口
		- 16 bit, 取指以字节为单位
		- 指出发送本报文段的一方的接收窗口的大小, 即接收缓存的可用空间大小, 用来表示接收方的接收能力
		- 流量控制: **使用接收方的接受能力的大小来控制发送方的数据发送量**
	- 检查: 检验和
		- 16 bit
		- 检查整个 TCP 报文段在传输过程中是否出现了误码
	- 建立连接: SYN
		- 当 `SYN==1 && ACK==0` 时, 表明这是一个 TCP 连接请求报文段
			- 若对方同意建立连接, 则在响应的 TCP 报文段的首部中令 `SYN==1 && ACK==1`
	- 释放连接: FIN
		- 当 `FIN==1` 时, 表明此 TCP 报文段的发送方已经将全部数据发送完毕, 现请求释放 TCP 连接
	- 复位 TCP 连接: RST
		- 当 `RST==1` 时, 表明 TCP 连接中出现严重差错, 必须释放连接, 然后在重新建立连接
			- `RST==1` 还可以用来拒绝一个非法的 TCP 报文段或拒绝打开一个 TCP 连接
	- 紧急: URG, 紧急指针
		- `URG==1` 时, 紧急指针字段有效
		- 在发送方有紧急数据时候, 可以将紧急数据"插队"到发送缓存的最前面, 并立刻封装到一个 TCP 报文段中进行发送
		- 紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据, 紧急数据之后是普通数据
	- 选项字段:
		- 最大报文段长度 MSS 选项: 指出 TCP 报文段数据载荷部分的最大长度, 而不是整个 TCP 报文段的长度
		- 窗口扩大选项: 扩大窗口, 提高吞吐率
		- 时间戳选项:
			- 用于计算往返时间 RTT
			- 用于处理序号超范围的情况, 有称为繁殖序号绕回 PAWS
		- 选择确认选项: 用来实现选择确认功能
	- 填充, 确保首部长度能够 4 字节整除
### TCP 的运输连接管理
- TCP 运输连接的三个阶段:
	- 建立 TCP 连接 (三报文握手)
	- 传输数据
	- 释放 TCP 连接 (四报文挥手)
#### 三报文握手
- 目的:
	- 使 TCP 双方能够确认对方的存在
	- 使 TCP 双方能够协商一些参数
	- 使 TCP 双方对运输实体资源进行分配和初始化
![TCP连接的三次握手.gif](https://raw.githubusercontent.com/alwaysmissin/picgo/main/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.gif)
- 请求连接的过程: 
	- 发送 TCP 连接**请求报文段**, 进入同步已发送状态
		- TCP 连接请求报文段和 TCP 连接请求确认报文段中 SYN=1
		- 初始化 seq=x, 作为 TCP 客户进程所选择的初始序号
		- TCP 规定 SYN 被设置为 1 的报文段不能携带数据, 但是要消耗掉一个序号. 因此, TCP 客户进程下一次发送的 TCP 报文段的数据载荷的第一个字节序号为`x+1`
	- 发送 TCP 连接**请求确认报文段,** 进入同步已接收状态
		- SYN=1, ACK=1
		- 同样初始化 seq=y, 作为 TCP 服务器进程所选择的初始序号
		- Ack=x+1, 是对 TCP 客户进程所选择的初始序号 x 的确认
	- 发送针对 TCP 连接请求确认报文段的普通 TCP 确认报文段, 进入连接已建立状态
- 第三个 TCP 报文段是否多余? 
	- 是为了防止已失效的 TCP 连接请求报文段突然又传送到了 TCP 服务器进程, 因而导致错误![三报文而不是二报文.gif](https://raw.githubusercontent.com/alwaysmissin/picgo/main/%E4%B8%89%E6%8A%A5%E6%96%87%E8%80%8C%E4%B8%8D%E6%98%AF%E4%BA%8C%E6%8A%A5%E6%96%87.gif)

#### 四报文释放 TCP 连接
![四报文关闭TCP.gif](https://raw.githubusercontent.com/alwaysmissin/picgo/main/%E5%9B%9B%E6%8A%A5%E6%96%87%E5%85%B3%E9%97%ADTCP.gif)
- 四报文释放:
	- 客户端发送 TCP 连接释放报文段, 并进入终止等待状态
	- 服务器发送 TCP 普通确认报文段, 并进入关闭等待状态
		- 发送完毕后,  从客户进程到服务进程的连接就释放了, 此时 TCP 连接处于**半关闭状态**
			- TCP 客户进程已经没有数据要发送了, 但 TCP 服务器进程如果还有数据要发送, TCP 客户进程**仍要接收**
	- 服务器发送 TCP 连接释放报文段, 并进入最后确认状态
		- `FIN=1`
		- `ACK=u+1`, 进行重复确认
	- 客户端发送 TCP 普通确认报文段, 并进入时间等待状态
		- 等待 2 MSL (Maximum Segment Lifetime):
			- 为什么? 如果在客户端返回 TCP 普通确认报文段的过程中报文段丢失, 而此时客户端已经进入关闭状态的话, 由服务器发来的超时重传的 TCP 连接释放报文段无法被接收, 导致服务器一直处于无法关闭的状态
	- 服务器撤销相应的传输控制块 TCB
	- 客户端撤销相应的传输控制块 TCB

### TCP 流量控制
#### 流量控制基本概念
- 流量控制: 解决因发送方因发送数据太快而导致接收方来不及接收, 造成接收方的接收缓冲溢出的问题
- 基本方法: 接收方根据自己的接收能力控制发送方的发送速率
#### 流量控制方法
![TCP流量控制.gif](https://raw.githubusercontent.com/alwaysmissin/picgo/main/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.gif)
> [!note] 零窗口探测报文段
> TCP 规定: 及时接收窗口值为 0, 也必须接收零窗口探测报文段, 确认报文段以及携带有紧急数据的报文段

### 拥塞控制
#### 基本概念
- 拥塞: 对网络中某一资源的需求超过了该资源送提供的可用部分, 网络性能就回变坏
- 若出现拥塞而不进行控制, 整个网络的吞吐量将随着输入负荷的增大而下降 ![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231110140207.png)
- 如果一个 TCP 发送方感知从它到目的地之间的路径上没什么拥塞, 则 TCP 发送方增加其发送速率; 如果感知到拥塞, 则发送方降低其发送速率
- 引出问题:
	- 发送方如何限制它向其连接发送流量的速率?
	- TCP 发送方如何感知从它到目的地之间的路径上存在拥塞呢?
	- 当发送方感知到拥塞时, 采用何种算法来改变其发送速率呢?
#### 拥塞控制的基本方法
> [!note] 流量控制与拥塞控制的区别:
>  - 流量控制与拥塞控制的区别: 
> 	 - 流量控制: 以接收方的接受能力控制发送方的发送速率
> 		 - 只与特定的点对点通信的发送方和接收方之间的流量有关
> 	 - 拥塞控制: 源点根据各方面因素, 按拥塞控制算法自行控制发送速率
> 		 - 全局性问题, 涉及网络中的所有主机, 路由器等
- 基本方法:
	- 开环控制:
		- 试图使用良好的设计来解决问题, 从一开始就保证问题不会发生, 一旦系统启动并且运行起来, 就不需要中途修正
		- 适用情况: 当网络的流量特征可以准确规定且性能要求可以事先获得
	- 闭环控制:
		- 一种基于反馈的控制方法, 包括以下三个部分:
			- 检测网络拥塞在何时何地发生
			- 吧拥塞发生的相关信息传送到可以采取行动的地方
			- 调整网络的运行以解决拥塞问题
		- 适用情况: 当网络的流量特征不能准确描述或者当网络不提供资源预留时
		- 因特网所采用的的就是闭环控制方法
- **拥塞窗口 cwnd**:
	- 对一个 TCP 发送方能向网络中发送流量的速率进行了限制
- 衡量网络拥塞的指标: 
	- 由于缓存溢出而丢弃的分组的百分比
	- 路由器的平均队列长度
	- 超时重传的分组数量
	- 平均分组时延和分组时延的标准差
- 闭环拥塞控制算法: 
	- 显式反馈算法: 从**拥塞节点向源点提供**关于网络中拥塞状态的显式反馈信息 ![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231110141031.png)
	- 隐式反馈算法: 源点自身通过对网络行为的观察来推断是否发生了拥塞
- 代价: 
	- 需要在节点之间交换信息和各种命令, 以便选择拥塞控制的策略并实施控制, 产生额外的开销; 
	- 需要预留一些资源用于特殊用户或特殊情况, 降低了网络资源的共享程度

#### TCP 的四种拥塞控制方法
- 假定: 
	- 数据是单方向传送的
	- 不考虑接收方对发送方的流量控制
	- 以 TCP 最大报文段 MSS 的个数作为讨论问题的单位
- 判断网络出现拥塞的依据: 没有按时收到应当到达的 TCP 确认报文
	- 即线路上发生了丢包事件
- 在不同情况下采取不同的方法 (ssthresh 慢开始门限): 
	- 当 cwnd<ssthresh: 慢开始算法
	- 当 cwnd>ssthresh: 停止使用慢开始算法而改用拥塞避免算法
	- 当 cwnd=ssthresh: 既可以使用慢开始算法, 也可以使用拥塞避免算法
##### 慢开始 slow start
- 每次翻一番
![慢开始.gif](https://raw.githubusercontent.com/alwaysmissin/picgo/main/%E6%85%A2%E5%BC%80%E5%A7%8B.gif)

##### 拥塞避免 congestion avoidance
- 每个 RTT 只将 cwnd 的值增加一个 MSS

##### 快恢复 fast recovery
- 当丢包事件出现时, cwnd 的值被设置为 1 个 MSS, 并且 ssthresh 的值设置为 cwnd 值的一半
![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231110144221.png)
##### 快重传 fast retransmit
- 快重传指发送方尽早进行重传, 而不是等待重传计时器超时再重传
	- 要求接收方不要等待自己发送数据时候才捎带确认, 而是要立即发送确认, 即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认
	- 发送方一旦收到 3 个连续的重复确认, 就将相应的报文段**立即重传**, 而不是等待重传计时器超时再重传 ![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231110144639.png)

- 优点: 让发送方尽早知道发生了个别 TCP 报文段的丢失
#### TCP 拥塞控制与网际层拥塞控制的关系

### TCP 可靠传输的实现
![TCP可靠传输.gif](https://raw.githubusercontent.com/alwaysmissin/picgo/main/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93.gif)

### TCP 超时重传时间的选择
- 过大过小都不合适
	- 过小: 不必要的重传增大网络负荷
	- 过大: 使网络的空闲时间增大, 降低了传输效率
- 超时重传时间的选择: 
	- 不能直接使用略大于某次测量得到的往返时间 RTT 样本的值作为超时重传时间 RTO
	- 但是, 可以利用每次测量得到的 RTT 样本计算加权平均往返时间 RTTs, 这样可以得到一个比较平滑的往返时间$RTT_s=(1-\alpha)\times RTT_s + \alpha \times RTT$
	- 超时重传时间 RTO 的值应略大于加权平均往返时间 RTTs 的值