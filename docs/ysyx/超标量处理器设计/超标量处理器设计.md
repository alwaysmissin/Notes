# 超标量处理器设计-姚永斌
## 超标量处理器设计概览
### 超标量处理器的流水线
#### 顺序执行
![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo20240418194107.png)
- P10: 所有的 FU 都要经历相同周期数的流水线, 即使他们什么也没做
- P11: 对于不同的 FU, 可以进行旁路的时机不同

#### 乱序执行
![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo20240418194319.png)
- P12: 寄存器的重命名在解码阶段完成, 也可以单独使用一个流水段

#### 对比
超标量处理器书上的顺序超标量和乱序超标量的图 ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo20240420112411.png)


## Cache
### Cache 的一般设计
#### Cache 的组成方式
- P17: 分支预测和 Cache 直接影响着超标量处理器的性能
- P18: L1 紧密耦合在处理器的流水线中, 是影响处理器性能的一个关键因素
- P18: 现代超标量处理器普遍采用哈佛结构, L1 Cache 包含两个物理结构: I-Cache 和 D-Cache
	- D-Cache 需要考虑读写, 而 I-Cache 只需要考虑读
- P18: L1 使用 SRAM 实现
- **P22: Cache 的访问一般都是处理器中的关键路径, 如果在一个周期内完成访问过程, 会占据大量的延迟, 因此要想使处理器运行在比较高的频率下, Cache 的访问需要使用流水线**![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo20240426124149.png)
#### Cache 的写入
- P26: 将确实地址对应的数据块从下级存储器中读取出来是必不可少的


## 指令解码
### 指令缓存
- P177: 从 I-Cache 中取出的指令个数多余每周期可以解码的指令个数
	- 需要在取指阶段和解码阶段之间添加缓存, 这个缓存本质上是 FIFO
	- 指令缓存是超标量处理器的必须部件: 
		- 即使 I-Cache 缺失, 指令缓存中也仍有一些指令
	- 多端口 FIFO, 但是使用交叠的方式, 使用多个单端口的 SRAM 实现, 从而避免多端口 SRAM 所带来的的硬件和速度上的限制

## 发射
### 概述
- P230: **对于顺序执行的处理器**, 指令按照程序中原始的顺序写到发射队列中, 此时发射队列就是一个 FIFO, 只有最旧的那条指令的源操作数都准备好了, 这条指令才会被发射, 若这条指令没有被发射, 则其后面的指令也无法继续发射
- P230: 发射队列的作用: 使用硬件**保存一定数量的指令**, 然后从中找出可执行的指令 (对于顺序, 则只检查队首的指令)
- P230: 是从顺序指令转到乱序执行的分界线
- P231: 发射阶段所涉及的部件: 
	- 发射队列 (Issue Queue)
	- 分配 (Allocation)电路: 从发射队列中找到空闲的空间, 将寄存器重命名之后的指令存储到其中
	- 选择 (Select)电路: 也称为仲裁电路, 选择指定数量的已准备好的指令, 进入 FU 中执行
	- 唤醒 (Wake-up)电路, 当一条指令经过 FU 执行得到结果时, 将其通知给发射队列中所有等待这个数据的指令, 进入 `ready` 状态, 向选择电路发出申请

#### 集中式 VS 分布式
- P232: 
	- 集中式 (Centralized Issue Queue, CIQ) -> 不同的 FU 公用一个发射队列
		- 选择电路和唤醒电路复杂, 增加面积和延迟
	- 分布式 (Distrubuted Issue Queue, DIQ) -> 每个 FU 拥有单独的发射队列
		- 简化电路设计
	- 集中式与分布式可以混合使用, 使部分 FU 共用一个发射队列

#### 数据捕捉 VS 非数据捕捉
- P232: 何时读取寄存器?
	- 数据捕捉: 在发射阶段之前读取寄存器, 被寄存器重命名后的指令会先读取物理寄存器堆
		- 若源寄存器的值还未被计算出来, 则将寄存器号带到发射队列中, 以供唤醒使用
		- **当指令被发射队列选中时候, 会将目的寄存器的编号进行广播**, 发射队列中的其他指令将自身的源寄存器编号与目的进行比对, 并在 payload RAM 中对应的位置进行标记; 当指令计算完毕后, 将结果写到 payload RAM 中 (这是通过旁路网络实现的), 这样的行为就像是 payload RAM 在捕捉 FU 计算的结果->数据捕捉
			- **这里的广播怎么实现? payload RAM 怎么进行捕捉**
		- payload RAM 的工作: 存储源操作数, 捕捉 FU 的结果
		- ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo20240520231513.png) 选择电路从发射队列中选中指令, 执行结束后通过旁路网络, FU 捕捉执行结果, wake-up 对应的源操作数
	- 非数据捕捉: 在发射阶段之后读取物理寄存器堆, 被重命名之后的指令不会读取物理寄存器堆, 而是直接将源寄存器的编号放到发射队列中, 在被选中后, 使用该编号读取寄存器堆, 将读取的值送到 FU 中
		- 非数据捕捉不需要 payload RAM 了, 因此减小了面积, 提高处理速度
- P232: 
	- machine width: 标记每周期可以解码和重命名的指令个数
	- issue width: 标记每周期最多可以在 FU 中并行执行的指令个数
	- 很多情况下 issue width < machine width, 因此要尽可能多的 issue width
- P232: 
	- 数据捕捉: 物理寄存器堆需要的读端口个数是 `machine width * 2`
	- 非数据捕捉: 物理寄存器堆需要的读端口个数是 `issue width * 2`
- P235: 决定了寄存器重命名的实现方式, 使用 ROB 进行寄存器重命名的时候, 会配合使用数据捕捉的发射方式, 在这种方法中, 指令在顺利地离开流水线时, 需要将结果从 ROB 中移动到 ARF 中, 采用数据捕捉的方式可以不同关心指令结果的位置变换

#### 压缩 VS 非压缩
- P235: 压缩发射队列: 当指令离开发射队列时候, 会出现空隙, 此时将后面的指令向前移动, 填充空隙, 保证队列中的指令顺序为 `oldest -> newest`, 这样可以使得 select 电路比较简单, 但是需要实现大量的 mux
- P237: 非压缩: 不会填充空隙, 则导致队列中的指令分布式没有规律的, 如果此时选择相对简单的选择电路, 则选择到的指令会相对随机, 处理器的性能上会有所下降

### 发射过程的流水线
#### 非数据捕捉的流水线
- P239: 唤醒的方法:
	- 简单: 当一条指令在 FU 中的到结果时候, 将发射队列中使用这条指令计算结果的所有源寄存器都置为 ready (tomasulo) -> 问题: 背靠背的指令延迟高 ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo20240521111329.png)
	- 当 A 被选中后, 就将发射队列中的相关源寄存器进行唤醒, 此时 B 可以向仲裁电路发出申请, 此时 B 在执行阶段时候, 就可以通过旁路网络获得 A 的结果 ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo20240521111654.png)
- P240: 仲裁和唤醒是在一个周期中的串行操作, 这样才能实现 RAW 关系的指令背靠背执行 ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo20240521112125.png)
	- 如果将仲裁和唤醒分为两个周期, 后面的指令需要等待一个周期才能被唤醒, 则无法达到这个目的: ![]( https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo20240521112153.png )
	- 这样的操作可以使处理器的频率变高但会影响指令并行度 (IPC), 原因是仲裁电路和唤醒电路都是复杂的电路, 放在一个周期内串行执行, 会使得时钟周期变长, 但是却可以使得指令背靠背执行, 但是分为两个周期, 会使得流水线更深, 相应的惩罚(mis-prediction penalty)增加
	- 且实际上, 不同指令的执行周期是不一样的, 如果将仲裁和唤醒放在一个周期内串行执行, 并不一定能够达到背靠背执行的效果

#### 数据捕捉的流水线
- P243: 采用 payload RAM 存储指令的源操作数, 当指令离开发射队列时候, 可以直接从 payload RAM 获取操作数 ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo20240521113319.png)
- P244: 可能更优的方法: 将仲裁和唤醒两个操作放在一个周期完成, 将 payload RAM 的读取作为一个单独的流水段, 指令被仲裁电路选中后, 对发射队列中相关的寄存器进行唤醒, 在下一个周期进行 payload RAM 的读取 ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo20240521113733.png)

### 分配


### 仲裁

### 唤醒


## 执行
### 旁路网络
#### 简单设计的旁路网络
- P289: 不同 FU 所需要的周期数不同可能会出现冲突 ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo20240521211132.png)
	- 处理方法: 按照推测唤醒中所述, 先假设不会存在冲突, 按照正常流程进行唤醒和仲裁, 在指令到达 FU 中被执行之前, 先检查当前 FU 是否可以被自己使用, 若本周期到达 FU 的指令的 latency 满足下图的情况, 则这条指令需要重新放回发射队列中, 重新参与仲裁. ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo20240521211746.png)

#### 复杂设计的旁路网络
- P295: 实际上, 并不需要在所有的 FU 之间都设置旁路网络, 如 AGU 的结果不会被 ALU 使用, LSU 只有在执行 L 时候的结果, 才有可能被 ALU 使用

### 操作数的选择
- P296: 将物理寄存器的信息保存在 Scoreboard 中 ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo20240521213753.png)
	- FU: 这个物理寄存器会在哪个 FU 中被计算出来
	- R: 这个物理寄存器的值已经被计算出来, 并且被写回了物理寄存器堆
- P297: 
	- select 阶段, 将 FU 信息写入到 ScoreBoard 中
	- write back 阶段, 将 R 信息写入到 ScoreBoard 中,
	- 后续的相关指令在进入流水线的 Execute 阶段时, 读取这个表格, **可以直接从寄存器读取, 也可以选择从旁路网络读取**

### Cluster
- P299: 将统一划分为多个
#### Cluster IQ

#### Cluster Bypass
- P304: 只有属于同一个 Cluster 的 FU 可以背靠背执行, 不同的 CLuster 只能通过寄存器传递