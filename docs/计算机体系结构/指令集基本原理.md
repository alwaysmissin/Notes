# 指令集基本原理
## 指令集体系结构分类
- 最基本的区别: **处理器内部的存储类型**
	- 包括: **栈, 累加器和寄存器组**
- 操作数的显式与隐式命名: ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo%2F20231119215401.png)
	- **栈**体系结构: 操作数隐式位于栈顶
	- **累加器**体系结构: 操作数为隐式的累加器
	- 通用**寄存器**体系结构: 只有显式的操作数
		- 要么是寄存器, 要么是存储地址
> [!note] 显式操作数
> 显式操作数可能直接从存储器访问, 也可能需要首先加载到临时存储中, 具体取决于具体的体系结构类别以及选择的特定指令
> 如上面的图片中, (c)中, 一个输入操作数是寄存器, 另一个输入操作数在存储器中, 结果保存在寄存器中. 而在 (d)中, **所有的操作数都是寄存器**, 而且和栈体系结构类似, 只能通过独立指令传送到存储器中
> ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo%2F20231119215833.png)

> [!note] 载入-存储寄存器结构出现的原因
> 1. 寄存器**快**于存储器
> 2. 对编译器来说, 使用寄存器的**效率**要高于使用其他内部存储形式
> 3. 寄存器可以用于保存变量. 当变量被分配到寄存器中时, 可以**降低内存的访问速度, 加快程序速度, 提高代码密度**

> [!note] 对于载入-存储寄存器结构, 多少个寄存器才算够?
> 取决于编译器如何使用这些寄存器.
> 多数编译器会为表达式求值保留一些寄存器, 为参数传递使用一些寄存器, 其余寄存器用于保存变量.
> 现代的编译器技术能够有效的使用大量寄存器, 导致了新体系结构中寄存器数量的增加.

- 三种常见通用寄存器计算机的优势与劣势: ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo%2F20231119220421.png)

## 存储器寻址
### 解释存储器地址
- 数据访问的两个问题
	- 字节顺序
	- 对齐
- 字节顺序: 大端或**小端**
- 对齐: 如果 $A\quad mod\quad s=0$, 则字节地址 $A$ 对大小为 $s$ 字节的对象的访问是对齐的 ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo%2F20231119220851.png)
> [!note] 为什么要设计一种带有对齐限制的计算机?
> 由于存储器的对齐边界通常是单字或双字的整倍数, 所以非对齐访问会**增加硬件的复杂度**
> 并且, 一个非对齐存储器访问可能需要多个对齐存储器访问, 因此, 即使在允许非对齐访问的计算机中, 采用对齐访问的程序也可以运行的更快一些.

### 寻址方式
![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo%2F20231119221203.png)
- 寻址方式的丰富可以**减少指令的数目**, 但也会**增加构建计算机的复杂度**, 对于实施这些寻址方式的计算机, 还可能**增加每条指令的平均时钟周期**
- 寻址方式的使用频率: ![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo%2F20231119221538.png)

### 位移量寻址方式
![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo%2F20231119222400.png)

### 立即数或直接操作数寻址方式
![image.png](https://jiunian-pic-1310185536.cos.ap-nanjing.myqcloud.com/picgo%2F20231119222436.png)

## 操作数的类型与大小
