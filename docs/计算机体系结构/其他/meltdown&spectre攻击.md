# meltdown&spectre 攻击
现代处理器使用分支预测和缓存提高 cpu 的性能, meltdown 和 spectre 攻击就是利用了现代处理器的这两点, 窃取用户的信息.
分支预测和缓存能够为计算机带来性能, 性能意味着更快的速度和更短的时间, meltdown 和 spectre 攻击就是利用了这个时间差来获得用户的信息.
先来简单的介绍一下分支预测和缓存吧.

## 缓存
即使内存相比硬盘已经很快了, 但是对于 cpu 来说, 还是不够快, 如果 cpu 总是在等待内存返回的结果, 那么可想而知, cpu 的运行速度会被内存拖垮, 因此在 cpu 的周围, 都有高速缓存的存在.
cpu 在进行访存时候, 会先查看缓存中是否有想要的数据, 如果缓存中有目标数据, 则可以直接从缓存中取用, 如果没有的话, 会将内存中的数据移动到缓存上来, 再读取缓存中的数据. 
对于上面这个过程, 可想而知, 如果缓存中已经有了这个数据, 读取的时间会快上不少.

## 分支预测
更准确的说, 应该是前瞻执行. 对于如下的代码: 
```
if (condition)
	code1;
	code2;
```
cpu 在执行上面这段代码时候, 很可能不能及时的获得 `condition`, 为了提高 cpu 的运行速度, cpu 会先执行 `if` 中的代码, 并且将其执行结果保存在某个地方, 当条件 `condition` 满足时候, 则可以直接将数据写入到寄存器中, 如果不满足, 则直接将数据丢弃.

## 发起攻击
虽然对于现代的操作系统来说, 一个进程是不能访问其他进程的数据的, 这会出现错误, 但是利用了缓存和分支预测机制, 程序可以通过某些奇技淫巧来获得其他进程中的数据.
在当前的进程中, 有一个数组, 我可以利用这个数组访问距离它很远的数据, 但如果这个访问的目标超出了当前进程的空间, 操作系统会将其拦下来, 因为它没有权限, 而在分支预测的情况下, 事情就变得不一样了.
对于以下情况: 
```
if (condition) 
	a[infinite];
```
即使对数组的访问超出了当前进程的空间, 操作系统也不会多说什么, 因为对于操作系统来说, 这并不是真正意义上执行了的代码, 就疏于检查: 操作系统认为在 `condition` 满足的情况下, 它会检查这段代码是否有权限, 而 `condition` 不满足的情况, 这段代码并不会被真正的执行. 
但对于 cpu 来说, 这是一段执行过的代码, 对于数据的访问, 会让它出现在缓存中, 此时在程序中, 只需要计算访问的时间, 就可以知道, 刚刚通过 `a[infinite]` 访问的其他进程中的数据是什么了.