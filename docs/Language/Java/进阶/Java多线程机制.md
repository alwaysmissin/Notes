# Java多线程机制

## 进程与线程
1. 线程之间可以共享内存
2. 用来实现数据交换、实时通信与必要的同步操作
3. 与进程的不同：现成的中断与恢复可以更加节省系统的开销
4. 线程的状态与生命周期
	1. 新建状态
	2. 可运行状态
	3. 中断状态
	4. 死亡状态
![](https://s2.loli.net/2022/03/28/wf1z3jeMvVr9Np4.png)

5. 线程的调度与优先级
	1. 优先级可以通过`setPriority(int grade)`方法来更改


## Thread类与线程的创建
1. 使用Thread的子类 **（例12-1）**
	1. 优点：
		1. 可以在子类中增加新的成员变量（新属性）
		2. 可以增加新的成员方法（新功能）
	2. 缺点
		1. Java不支持多继承，无法拓展其他类
2. 使用Thread类，通过接口实现 **（例12-2）**
	1. 通常使用的构造方法：`Thread(Runnable target)`
	2. 对于使用同一目标对象的线程，**目标对象的成员变量就是这些线程共享的数据单元** **（例12-3）**

![创建线程的方法](https://s2.loli.net/2022/03/24/kaDzy5CR1hlujQ4.png)



## 线程的常用方法
1. `start()`
2. `run()`：与Runnable接口中`run()`方法相同
3. `sleep(int millsecond)`：**static方法**，如果线程在休眠时候被打断，就会抛出`InterruptedException`异常，**必须在try-catch语句中使用sleep方法**
4. `isAlive()`
5. `currentThread()`：返回正在使用cpu资源的线程
6. `interrupt()`：用来吵醒休眠的线程，重新进入Runnable状态


## 线程同步
1. 若干个线程都需要使用`synchronized`修饰的**方法或代码块**
2. 多线程调用`synchronized` 方法必须遵守同步机制（即排队使用）**（例12-7）**


## 协调同步的线程
1. `wait()`方法
	1. 中断线程的执行，暂时**让出**cpu的使用权等待通知后，才参与CPU资源抢夺
2. `yield()`方法
	1. 将CPU资源让出，但立刻加入CPU资源的争抢
3. `notifyAll()`方法
	1. **通知所有**由于使用同步方法而处于等待状态的方法结束等待，进入就绪状态
4. `notify()`方法
	1. **通知指定**的使用同步方法而处于等待状态的方法结束等待， 进入就绪状态
- 注：不可以在非同步方法中使用以上三个方法
 

## 线程联合
1. 一个线程A在占有cpu资源期间可以让其他线程调用`join()`与本线程联合
2. 联合后A将立即中断执行，直到B线程执行完毕，A再重新排队等待cpu资源

## [[GUI]]线程
1. 两个重要线程：
	1. `AWT-EventQuecue`
		1. 负责处理GUI事件
	2. `AWT-Windows`
		1. 负责将窗体或组件绘制到桌面


## 守护线程
1. 守护线程：当程序中的所有用户线程都已经结束运行时，守护线程立刻结束运行（无视`run()`方法）
2. 常见的守护线程：垃圾回收机制
- **注：一个线程必须在运行之前设置自己是否为守护线程**
3. 声明方式：`ThreadName.setDaemon(true)`