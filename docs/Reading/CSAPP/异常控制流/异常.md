# 异常
- 异常: 控制流中的突变, 用来响应处理器状态中的某些变化
	- 部分由硬件实现, 部分由操作系统实现
![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231007162039.png)
- 状态的变化称为事件, 事件可能与当前指令的执行直接相关
- 异常处理程序的过程:
	1. 处理器检测到有事件发生
	2. 通过异常表(异常表), 进行一个间接过程调用, 跳转到一个专门设计用来处理这类事件的操作系统子程序
	3. 完成处理, 执行特殊的"从中断中返回"的指令, **根据引起异常的事件的类型, 会发生以下三种情况之一**:
		1. 重新执行指令: 处理程序将控制返回给当前指令(事件发生时正在执行的指令)
		2. 继续执行指令: 处理程序将控制返回
		3. 终止: 终止被中断的程序

## 异常处理
- 系统中, 每种类型的异常都被分配了一个**唯一**的**非负整数**的异常号(Exception Number)
	- 部分由处理器的设计者分配
		- 除零、缺页、内存访问违例、算术运算溢出
	- 其余有操作系统内核设计者设计
		- 系统调用和来自外部I/O设备的信号
- 在系统启动时， 操作系统分配和初始化一张**异常表**![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231007162926.png)
	- 异常表的起始地址存放在**异常表基址寄存器**中(exception table base register)![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231007163042.png)

> [!note] 异常与过程调用的不同之处
> - 过程调用时, 在跳转到处理程序之前, 处理器将返回地址压入栈中. 然而, 根据异常的类型, 返回的地址并非原来的下一条指令的地址
> - 处理器也可能把一些额外的处理器状态压入栈中, 在处理程序返回时, 重新开始执行被中断的程序会需要这些状态
> - 如果控制从用户程序转移到内核中, 所有的项目将被压到内核栈中, 而不是用户栈中
> - 异常处理程序运行在内核模式下

## 异常的类别
- 四种:

|类别|原因|异步/同步|返回行为|
|:-:|:-:|:-:|:-:|
|中断|来自I/O设备的信号|异步|总是返回到下一条指令|
|陷阱|有意的异常|同步|总是返回到下一条指令|
|故障|潜在可恢复的错误|同步|可能返回到当前指令|
|终止|不可恢复的错误|同步|不会返回|
### 中断interrupt

### 陷阱和系统调用trap and syscall
### 故障fault
### 终止abort