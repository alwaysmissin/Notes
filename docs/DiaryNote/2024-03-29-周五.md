# 参考文档
## vivado 的基本配置
- `Simulation`->`Simulation`->`xsim. simulate. log_all_signals`
## 七段数码管
```verilog
module seg7(
    input clk,
    input reset,
    input [3:0] seg0,
    input [3:0] seg1,
    input [3:0] seg2,
    input [3:0] seg3,
    output reg [3:0] an,
    output reg [6:0] seg
    );
reg [1:0] state;
reg [3:0] bcd;

always @(posedge clk) begin
    if (reset) 
        state <= 0;
    else
        state <= state + 1;
end

always @(*) begin
    case (state)
        2'b00: begin
            an = 4'b0001;
            bcd = seg0;
        end
        2'b01: begin
            an = 4'b0010;
            bcd = seg1;
        end
        2'b10: begin
            an = 4'b0100;
            bcd = seg2;
        end
        2'b11: begin
            an = 4'b1000;
            bcd = seg3;
        end
    endcase
end

always @(*) begin
    case (bcd) 
        4'b0000: seg = 7'b1111110;
        4'b0001: seg = 7'b0110000;
        4'b0010: seg = 7'b1101101;
        4'b0011: seg = 7'b1111001;
        4'b0100: seg = 7'b0110011;
        4'b0101: seg = 7'b1011011;
        4'b0110: seg = 7'b1011111;
        4'b0111: seg = 7'b1110000;
        4'b1000: seg = 7'b1111111;
        4'b1001: seg = 7'b1111011;
        default: seg = 7'b0000000;
    endcase
end
endmodule
```
## 时钟分频
```verilog
module clk_div(
    input clk,
    input rst,
    output reg clk_div
    );
parameter N = 32'd51200, WIDTH=32-1;
reg [WIDTH-1:0] cnt;

always @(posedge clk) begin
    if (rst) begin
        cnt <= 0;
        clk_div <= 0;
    end
    else if (cnt == N - 1) begin
        cnt <= 0;
        clk_div <= ~clk_div; 
    end
    else begin
        cnt <= cnt + 1;
    end
end

endmodule
```
- 使用: 
```verilog
// 将100MHz偶数分频为2Hz(时钟周期为1s)
clk_div #(
	.N(50*1024*1024)
) clk_div_0 (
	.clk(clk),
	.rst(rst),
	.clk_div(clk_div)
);
```
## BCD 码
```verilog
module bin_to_bcd(
    input clk,
    input start,
    input [15:0] bin,
    output reg [3:0] d,
    output reg [3:0] d10,
    output reg [3:0] d100,
    output reg [3:0] d1000,
    output reg [3:0] d10000
    );

reg [3:0] d_reg, d10_reg, d100_reg, d1000_reg, d10000_reg;

integer i;
always @(*) begin
    if (start) begin
        d_reg = 0;
        d10_reg = 0;
        d100_reg = 0;
        d1000_reg = 0;
        d10000_reg = 0;
        for (i = 15;i >= 0;i = i - 1) begin
            d_reg = d_reg >= 5 ? d_reg + 3 : d_reg;
            d10_reg = d10_reg >= 5 ? d10_reg + 3 : d10_reg;
            d100_reg = d100_reg >= 5 ? d100_reg + 3 : d100_reg;
            d1000_reg = d1000_reg >= 5 ? d1000_reg + 3 : d1000_reg;
            d10000_reg = d10000_reg >= 5 ? d10000_reg + 3 : d10000_reg;
            d10000_reg = {d10000_reg[2:0], d1000_reg[3]};
            d1000_reg = {d1000_reg[2:0], d100_reg[3]};
            d100_reg = {d100_reg[2:0], d10_reg[3]};
            d10_reg = {d10_reg[2:0], d_reg[3]};
            d_reg = {d_reg[2:0], bin[i]};
        end
    end
    else begin
        d_reg = 0;
        d10_reg = 0;
        d100_reg = 0;
        d1000_reg = 0;
        d10000_reg = 0;
    end
end

always @(posedge clk) begin
    d <= d_reg;
    d10 <= d10_reg;
    d100 <= d100_reg;
    d1000 <= d1000_reg;
    d10000 <= d10000_reg;
end
// assign d = d;
// assign d10 = d10;
// assign d100 = d100;
// assign d1000 = d1000;
// assign d10000 = d10000;
endmodule
```
## 引脚绑定约束
- 顶层模块
```verilog
module bcd_top(
    input clk,
    input [7:0] in,
    output [3:0] seg_en_1,
    output [3:0] seg_en_0,
    output [6:0] seg_1,
    output [6:0] seg_0
    );
```
- 引脚绑定文件: 
```tcl
set_property PACKAGE_PIN P5 [get_ports {in[7]}]
set_property PACKAGE_PIN P4 [get_ports {in[6]}]
set_property PACKAGE_PIN P3 [get_ports {in[5]}]
set_property PACKAGE_PIN P2 [get_ports {in[4]}]
set_property PACKAGE_PIN R2 [get_ports {in[3]}]
set_property PACKAGE_PIN M4 [get_ports {in[2]}]
set_property PACKAGE_PIN N4 [get_ports {in[1]}]
set_property PACKAGE_PIN R1 [get_ports {in[0]}]

set_property PACKAGE_PIN G1 [get_ports {seg_en_0[3]}]
set_property PACKAGE_PIN F1 [get_ports {seg_en_0[2]}]
set_property PACKAGE_PIN E1 [get_ports {seg_en_0[1]}]
set_property PACKAGE_PIN G6 [get_ports {seg_en_0[0]}]
set_property PACKAGE_PIN B2 [get_ports {seg_0[0]}]
set_property PACKAGE_PIN B3 [get_ports {seg_0[1]}]
set_property PACKAGE_PIN A1 [get_ports {seg_0[2]}]
set_property PACKAGE_PIN B1 [get_ports {seg_0[3]}]
set_property PACKAGE_PIN A3 [get_ports {seg_0[4]}]
set_property PACKAGE_PIN A4 [get_ports {seg_0[5]}]
set_property PACKAGE_PIN B4 [get_ports {seg_0[6]}]

set_property PACKAGE_PIN G2 [get_ports {seg_en_1[3]}]
set_property PACKAGE_PIN C2 [get_ports {seg_en_1[2]}]
set_property PACKAGE_PIN C1 [get_ports {seg_en_1[1]}]
set_property PACKAGE_PIN H1 [get_ports {seg_en_1[0]}]
set_property PACKAGE_PIN F3 [get_ports {seg_1[2]}]
set_property PACKAGE_PIN E2 [get_ports {seg_1[1]}]
set_property PACKAGE_PIN D2 [get_ports {seg_1[0]}]
set_property PACKAGE_PIN F4 [get_ports {seg_1[3]}]
set_property PACKAGE_PIN D3 [get_ports {seg_1[4]}]
set_property PACKAGE_PIN E3 [get_ports {seg_1[5]}]
set_property PACKAGE_PIN D4 [get_ports {seg_1[6]}]

set_property IOSTANDARD LVCMOS18 [get_ports {in[7]}]
set_property IOSTANDARD LVCMOS18 [get_ports {in[6]}]
set_property IOSTANDARD LVCMOS18 [get_ports {in[5]}]
set_property IOSTANDARD LVCMOS18 [get_ports {in[4]}]
set_property IOSTANDARD LVCMOS18 [get_ports {in[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {in[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {in[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {in[0]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_0[6]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_0[5]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_0[4]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_0[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_0[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_0[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_0[0]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_1[6]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_1[5]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_1[4]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_1[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_1[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_1[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_1[0]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_en_0[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_en_0[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_en_0[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_en_0[0]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_en_1[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_en_1[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_en_1[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {seg_en_1[0]}]
set_property IOSTANDARD LVCMOS18 [get_ports clk]
```
- 也可以以类似的方法进行声明: `set_property -dict {PACKAGE_PIN J3 IOSTANDARD LVCMOS33} [get_ports jump]`
```verilog
/////////////////////////////系统时钟和复位////////////////////////////////////
set_property -dict {PACKAGE_PIN P17 IOSTANDARD LVCMOS33} [get_ports sys_clk_in ]
set_property -dict {PACKAGE_PIN P15 IOSTANDARD LVCMOS33} [get_ports sys_rst_n  ]

/////////////////////////////串口/////////////////////////////////////////////
set_property -dict {PACKAGE_PIN N5 IOSTANDARD LVCMOS33} [get_ports PC_Uart_rxd]
set_property -dict {PACKAGE_PIN T4 IOSTANDARD LVCMOS33} [get_ports PC_Uart_txd]

////////////////////////////////蓝牙///////////////////////////////////////////
set_property -dict {PACKAGE_PIN L3 IOSTANDARD LVCMOS33} [get_ports BT_Uart_rxd]
set_property -dict {PACKAGE_PIN N2 IOSTANDARD LVCMOS33} [get_ports BT_Uart_txd]

set_property -dict {PACKAGE_PIN D18 IOSTANDARD LVCMOS33} [get_ports {bt_ctrl_o[0]}]
set_property -dict {PACKAGE_PIN M2  IOSTANDARD LVCMOS33} [get_ports {bt_ctrl_o[1]}]
set_property -dict {PACKAGE_PIN H15 IOSTANDARD LVCMOS33} [get_ports {bt_ctrl_o[2]}]
set_property -dict {PACKAGE_PIN C16 IOSTANDARD LVCMOS33} [get_ports {bt_ctrl_o[3]}]
set_property -dict {PACKAGE_PIN E18 IOSTANDARD LVCMOS33} [get_ports {bt_ctrl_o[4]}]

set_property -dict {PACKAGE_PIN C17 IOSTANDARD LVCMOS33} [get_ports bt_mcu_int_i]

///////////////////////////////音频接口////////////////////////////////////////
set_property -dict {PACKAGE_PIN T1 IOSTANDARD LVCMOS33} [get_ports audio_pwm_o]
set_property -dict {PACKAGE_PIN M6 IOSTANDARD LVCMOS33} [get_ports audio_sd_o ]

//////////////////////////////////iic////////////////////////////////////////////
set_property -dict {PACKAGE_PIN F18 IOSTANDARD LVCMOS33} [get_ports pw_iic_scl_io]
set_property -dict {PACKAGE_PIN G18 IOSTANDARD LVCMOS33} [get_ports pw_iic_sda_io]

//////////////////////////////////XADC模数转换///////////////////////////////////
set_property -dict {PACKAGE_PIN B12 IOSTANDARD LVCMOS33} [get_ports XADC_AUX_v_n  ]
set_property -dict {PACKAGE_PIN C12 IOSTANDARD LVCMOS33} [get_ports XADC_AUX_v_p  ]
set_property -dict {PACKAGE_PIN K9  IOSTANDARD LVCMOS33} [get_ports XADC_VP_VN_v_n]
set_property -dict {PACKAGE_PIN J10 IOSTANDARD LVCMOS33} [get_ports XADC_VP_VN_v_p]

/////////////////////////////////////5个按键//////////////////////////////////////
set_property -dict {PACKAGE_PIN R11 IOSTANDARD LVCMOS33} [get_ports {btn_pin[0]}]
set_property -dict {PACKAGE_PIN R17 IOSTANDARD LVCMOS33} [get_ports {btn_pin[1]}]
set_property -dict {PACKAGE_PIN R15 IOSTANDARD LVCMOS33} [get_ports {btn_pin[2]}]
set_property -dict {PACKAGE_PIN V1  IOSTANDARD LVCMOS33} [get_ports {btn_pin[3]}]
set_property -dict {PACKAGE_PIN U4  IOSTANDARD LVCMOS33} [get_ports {btn_pin[4]}]

///////////////////////////////////拨码开关sw0~sw7////////////////////////////////
set_property -dict {PACKAGE_PIN P5 IOSTANDARD LVCMOS33} [get_ports {sw_pin[0]}]
set_property -dict {PACKAGE_PIN P4 IOSTANDARD LVCMOS33} [get_ports {sw_pin[1]}]
set_property -dict {PACKAGE_PIN P3 IOSTANDARD LVCMOS33} [get_ports {sw_pin[2]}]
set_property -dict {PACKAGE_PIN P2 IOSTANDARD LVCMOS33} [get_ports {sw_pin[3]}]
set_property -dict {PACKAGE_PIN R2 IOSTANDARD LVCMOS33} [get_ports {sw_pin[4]}]
set_property -dict {PACKAGE_PIN M4 IOSTANDARD LVCMOS33} [get_ports {sw_pin[5]}]
set_property -dict {PACKAGE_PIN N4 IOSTANDARD LVCMOS33} [get_ports {sw_pin[6]}]
set_property -dict {PACKAGE_PIN R1 IOSTANDARD LVCMOS33} [get_ports {sw_pin[7]}]

//////////////////////////////////拨码开关sw8~sw15/////////////////////////////
set_property -dict {PACKAGE_PIN U3 IOSTANDARD LVCMOS33} [get_ports {dip_pin[0]}]
set_property -dict {PACKAGE_PIN U2 IOSTANDARD LVCMOS33} [get_ports {dip_pin[1]}]
set_property -dict {PACKAGE_PIN V2 IOSTANDARD LVCMOS33} [get_ports {dip_pin[2]}]
set_property -dict {PACKAGE_PIN V5 IOSTANDARD LVCMOS33} [get_ports {dip_pin[3]}]
set_property -dict {PACKAGE_PIN V4 IOSTANDARD LVCMOS33} [get_ports {dip_pin[4]}]
set_property -dict {PACKAGE_PIN R3 IOSTANDARD LVCMOS33} [get_ports {dip_pin[5]}]
set_property -dict {PACKAGE_PIN T3 IOSTANDARD LVCMOS33} [get_ports {dip_pin[6]}]
set_property -dict {PACKAGE_PIN T5 IOSTANDARD LVCMOS33} [get_ports {dip_pin[7]}]


//////////////////////////////////////LED0~LED15////////////////////////////////
set_property -dict {PACKAGE_PIN F6 IOSTANDARD LVCMOS33} [get_ports {led_pin[0]}]
set_property -dict {PACKAGE_PIN G4 IOSTANDARD LVCMOS33} [get_ports {led_pin[1]}]
set_property -dict {PACKAGE_PIN G3 IOSTANDARD LVCMOS33} [get_ports {led_pin[2]}]
set_property -dict {PACKAGE_PIN J4 IOSTANDARD LVCMOS33} [get_ports {led_pin[3]}]
set_property -dict {PACKAGE_PIN H4 IOSTANDARD LVCMOS33} [get_ports {led_pin[4]}]
set_property -dict {PACKAGE_PIN J3 IOSTANDARD LVCMOS33} [get_ports {led_pin[5]}]
set_property -dict {PACKAGE_PIN J2 IOSTANDARD LVCMOS33} [get_ports {led_pin[6]}]
set_property -dict {PACKAGE_PIN K2 IOSTANDARD LVCMOS33} [get_ports {led_pin[7]}]

set_property -dict {PACKAGE_PIN K1 IOSTANDARD LVCMOS33} [get_ports {led_pin[8]}]
set_property -dict {PACKAGE_PIN H6 IOSTANDARD LVCMOS33} [get_ports {led_pin[9]}]
set_property -dict {PACKAGE_PIN H5 IOSTANDARD LVCMOS33} [get_ports {led_pin[10]}]
set_property -dict {PACKAGE_PIN J5 IOSTANDARD LVCMOS33} [get_ports {led_pin[11]}]
set_property -dict {PACKAGE_PIN K6 IOSTANDARD LVCMOS33} [get_ports {led_pin[12]}]
set_property -dict {PACKAGE_PIN L1 IOSTANDARD LVCMOS33} [get_ports {led_pin[13]}]
set_property -dict {PACKAGE_PIN M1 IOSTANDARD LVCMOS33} [get_ports {led_pin[14]}]
set_property -dict {PACKAGE_PIN K3 IOSTANDARD LVCMOS33} [get_ports {led_pin[15]}]

///////////////////////////////8个数码管位选信号/////////////////////////////////
set_property -dict {PACKAGE_PIN G2 IOSTANDARD LVCMOS33} [get_ports {seg_cs_pin[0]}]
set_property -dict {PACKAGE_PIN C2 IOSTANDARD LVCMOS33} [get_ports {seg_cs_pin[1]}]
set_property -dict {PACKAGE_PIN C1 IOSTANDARD LVCMOS33} [get_ports {seg_cs_pin[2]}]
set_property -dict {PACKAGE_PIN H1 IOSTANDARD LVCMOS33} [get_ports {seg_cs_pin[3]}]
set_property -dict {PACKAGE_PIN G1 IOSTANDARD LVCMOS33} [get_ports {seg_cs_pin[4]}]
set_property -dict {PACKAGE_PIN F1 IOSTANDARD LVCMOS33} [get_ports {seg_cs_pin[5]}]
set_property -dict {PACKAGE_PIN E1 IOSTANDARD LVCMOS33} [get_ports {seg_cs_pin[6]}]
set_property -dict {PACKAGE_PIN G6 IOSTANDARD LVCMOS33} [get_ports {seg_cs_pin[7]}]

///////////////////////////////////数码管段选信号//////////////////////////////////
set_property -dict {PACKAGE_PIN B4 IOSTANDARD LVCMOS33} [get_ports {seg_data_0_pin[0]}]
set_property -dict {PACKAGE_PIN A4 IOSTANDARD LVCMOS33} [get_ports {seg_data_0_pin[1]}]
set_property -dict {PACKAGE_PIN A3 IOSTANDARD LVCMOS33} [get_ports {seg_data_0_pin[2]}]
set_property -dict {PACKAGE_PIN B1 IOSTANDARD LVCMOS33} [get_ports {seg_data_0_pin[3]}]
set_property -dict {PACKAGE_PIN A1 IOSTANDARD LVCMOS33} [get_ports {seg_data_0_pin[4]}]
set_property -dict {PACKAGE_PIN B3 IOSTANDARD LVCMOS33} [get_ports {seg_data_0_pin[5]}]
set_property -dict {PACKAGE_PIN B2 IOSTANDARD LVCMOS33} [get_ports {seg_data_0_pin[6]}]
set_property -dict {PACKAGE_PIN D5 IOSTANDARD LVCMOS33} [get_ports {seg_data_0_pin[7]}]

set_property -dict {PACKAGE_PIN D4 IOSTANDARD LVCMOS33} [get_ports {seg_data_1_pin[0]}]
set_property -dict {PACKAGE_PIN E3 IOSTANDARD LVCMOS33} [get_ports {seg_data_1_pin[1]}]
set_property -dict {PACKAGE_PIN D3 IOSTANDARD LVCMOS33} [get_ports {seg_data_1_pin[2]}]
set_property -dict {PACKAGE_PIN F4 IOSTANDARD LVCMOS33} [get_ports {seg_data_1_pin[3]}]
set_property -dict {PACKAGE_PIN F3 IOSTANDARD LVCMOS33} [get_ports {seg_data_1_pin[4]}]
set_property -dict {PACKAGE_PIN E2 IOSTANDARD LVCMOS33} [get_ports {seg_data_1_pin[5]}]
set_property -dict {PACKAGE_PIN D2 IOSTANDARD LVCMOS33} [get_ports {seg_data_1_pin[6]}]
set_property -dict {PACKAGE_PIN H2 IOSTANDARD LVCMOS33} [get_ports {seg_data_1_pin[7]}]

////////////////////////////////////VGA行同步场同步信号///////////////////////////////
set_property -dict {PACKAGE_PIN D7 IOSTANDARD LVCMOS33} [get_ports vga_hs_pin]
set_property -dict {PACKAGE_PIN C4 IOSTANDARD LVCMOS33} [get_ports vga_vs_pin]

///////////////////////////////////////VGA红绿蓝信号//////////////////////////////////
set_property -dict {PACKAGE_PIN F5 IOSTANDARD LVCMOS33} [get_ports {vga_data_pin[0]}]
set_property -dict {PACKAGE_PIN C6 IOSTANDARD LVCMOS33} [get_ports {vga_data_pin[1]}]
set_property -dict {PACKAGE_PIN C5 IOSTANDARD LVCMOS33} [get_ports {vga_data_pin[2]}]
set_property -dict {PACKAGE_PIN B7 IOSTANDARD LVCMOS33} [get_ports {vga_data_pin[3]}]
set_property -dict {PACKAGE_PIN B6 IOSTANDARD LVCMOS33} [get_ports {vga_data_pin[4]}]
set_property -dict {PACKAGE_PIN A6 IOSTANDARD LVCMOS33} [get_ports {vga_data_pin[5]}]
set_property -dict {PACKAGE_PIN A5 IOSTANDARD LVCMOS33} [get_ports {vga_data_pin[6]}]
set_property -dict {PACKAGE_PIN D8 IOSTANDARD LVCMOS33} [get_ports {vga_data_pin[7]}]
set_property -dict {PACKAGE_PIN C7 IOSTANDARD LVCMOS33} [get_ports {vga_data_pin[8]}]
set_property -dict {PACKAGE_PIN E6 IOSTANDARD LVCMOS33} [get_ports {vga_data_pin[9]}]
set_property -dict {PACKAGE_PIN E5 IOSTANDARD LVCMOS33} [get_ports {vga_data_pin[10]}]
set_property -dict {PACKAGE_PIN E7 IOSTANDARD LVCMOS33} [get_ports {vga_data_pin[11]}]

/////////////////////////////////////////DAC数模转换//////////////////////////////////
set_property -dict {PACKAGE_PIN R5 IOSTANDARD LVCMOS33} [get_ports dac_ile]
set_property -dict {PACKAGE_PIN N6 IOSTANDARD LVCMOS33} [get_ports dac_cs_n]
set_property -dict {PACKAGE_PIN V6 IOSTANDARD LVCMOS33} [get_ports dac_wr1_n]
set_property -dict {PACKAGE_PIN R6 IOSTANDARD LVCMOS33} [get_ports dac_wr2_n]
set_property -dict {PACKAGE_PIN V7 IOSTANDARD LVCMOS33} [get_ports dac_xfer_n]

set_property -dict {PACKAGE_PIN T8 IOSTANDARD LVCMOS33} [get_ports {dac_data[0]}]
set_property -dict {PACKAGE_PIN R8 IOSTANDARD LVCMOS33} [get_ports {dac_data[1]}]
set_property -dict {PACKAGE_PIN T6 IOSTANDARD LVCMOS33} [get_ports {dac_data[2]}]
set_property -dict {PACKAGE_PIN R7 IOSTANDARD LVCMOS33} [get_ports {dac_data[3]}]
set_property -dict {PACKAGE_PIN U6 IOSTANDARD LVCMOS33} [get_ports {dac_data[4]}]
set_property -dict {PACKAGE_PIN U7 IOSTANDARD LVCMOS33} [get_ports {dac_data[5]}]
set_property -dict {PACKAGE_PIN V9 IOSTANDARD LVCMOS33} [get_ports {dac_data[6]}]
set_property -dict {PACKAGE_PIN U9 IOSTANDARD LVCMOS33} [get_ports {dac_data[7]}]

////////////////////////////////////////PS2/////////////////////////////////////
set_property -dict {PACKAGE_PIN K5 IOSTANDARD LVCMOS33} [get_ports  ps2_clk  ]
set_property -dict {PACKAGE_PIN L4 IOSTANDARD LVCMOS33} [get_ports  ps2_data ]


/////////////////////////////////////////SDRAM//////////////////////////////////////
set_property -dict {PACKAGE_PIN L15 IOSTANDARD LVCMOS33} [get_ports {sram_addr[18]}]
set_property -dict {PACKAGE_PIN L16 IOSTANDARD LVCMOS33} [get_ports {sram_addr[17]}]
set_property -dict {PACKAGE_PIN L18 IOSTANDARD LVCMOS33} [get_ports {sram_addr[16]}]
set_property -dict {PACKAGE_PIN M18 IOSTANDARD LVCMOS33} [get_ports {sram_addr[15]}]
set_property -dict {PACKAGE_PIN R12 IOSTANDARD LVCMOS33} [get_ports {sram_addr[14]}]
set_property -dict {PACKAGE_PIN R13 IOSTANDARD LVCMOS33} [get_ports {sram_addr[13]}]
set_property -dict {PACKAGE_PIN M13 IOSTANDARD LVCMOS33} [get_ports {sram_addr[12]}]
set_property -dict {PACKAGE_PIN R18 IOSTANDARD LVCMOS33} [get_ports {sram_addr[11]}]
set_property -dict {PACKAGE_PIN T18 IOSTANDARD LVCMOS33} [get_ports {sram_addr[10]}]
set_property -dict {PACKAGE_PIN N14 IOSTANDARD LVCMOS33} [get_ports {sram_addr[9]}]
set_property -dict {PACKAGE_PIN P14 IOSTANDARD LVCMOS33} [get_ports {sram_addr[8]}]
set_property -dict {PACKAGE_PIN N17 IOSTANDARD LVCMOS33} [get_ports {sram_addr[7]}]
set_property -dict {PACKAGE_PIN P18 IOSTANDARD LVCMOS33} [get_ports {sram_addr[6]}]
set_property -dict {PACKAGE_PIN M16 IOSTANDARD LVCMOS33} [get_ports {sram_addr[5]}]
set_property -dict {PACKAGE_PIN M17 IOSTANDARD LVCMOS33} [get_ports {sram_addr[4]}]
set_property -dict {PACKAGE_PIN N15 IOSTANDARD LVCMOS33} [get_ports {sram_addr[3]}]
set_property -dict {PACKAGE_PIN N16 IOSTANDARD LVCMOS33} [get_ports {sram_addr[2]}]
set_property -dict {PACKAGE_PIN T14 IOSTANDARD LVCMOS33} [get_ports {sram_addr[1]}]
set_property -dict {PACKAGE_PIN T15 IOSTANDARD LVCMOS33} [get_ports {sram_addr[0]}]

set_property -dict {PACKAGE_PIN V15 IOSTANDARD LVCMOS33} [get_ports sram_ce_n]
set_property -dict {PACKAGE_PIN R10 IOSTANDARD LVCMOS33} [get_ports sram_lb_n]
set_property -dict {PACKAGE_PIN T16 IOSTANDARD LVCMOS33} [get_ports sram_oe_n]
set_property -dict {PACKAGE_PIN R16 IOSTANDARD LVCMOS33} [get_ports sram_ub_n]
set_property -dict {PACKAGE_PIN V16 IOSTANDARD LVCMOS33} [get_ports sram_we_n]

set_property -dict {PACKAGE_PIN T10 IOSTANDARD LVCMOS33} [get_ports {sram_data[15]}]
set_property -dict {PACKAGE_PIN T9  IOSTANDARD LVCMOS33} [get_ports {sram_data[14]}]
set_property -dict {PACKAGE_PIN U13 IOSTANDARD LVCMOS33} [get_ports {sram_data[13]}]
set_property -dict {PACKAGE_PIN T13 IOSTANDARD LVCMOS33} [get_ports {sram_data[12]}]
set_property -dict {PACKAGE_PIN V14 IOSTANDARD LVCMOS33} [get_ports {sram_data[11]}]
set_property -dict {PACKAGE_PIN U14 IOSTANDARD LVCMOS33} [get_ports {sram_data[10]}]
set_property -dict {PACKAGE_PIN V11 IOSTANDARD LVCMOS33} [get_ports {sram_data[9]}]
set_property -dict {PACKAGE_PIN V10 IOSTANDARD LVCMOS33} [get_ports {sram_data[8]}]
set_property -dict {PACKAGE_PIN V12 IOSTANDARD LVCMOS33} [get_ports {sram_data[7]}]
set_property -dict {PACKAGE_PIN U12 IOSTANDARD LVCMOS33} [get_ports {sram_data[6]}]
set_property -dict {PACKAGE_PIN U11 IOSTANDARD LVCMOS33} [get_ports {sram_data[5]}]
set_property -dict {PACKAGE_PIN T11 IOSTANDARD LVCMOS33} [get_ports {sram_data[4]}]
set_property -dict {PACKAGE_PIN V17 IOSTANDARD LVCMOS33} [get_ports {sram_data[3]}]
set_property -dict {PACKAGE_PIN U16 IOSTANDARD LVCMOS33} [get_ports {sram_data[2]}]
set_property -dict {PACKAGE_PIN U18 IOSTANDARD LVCMOS33} [get_ports {sram_data[1]}]
set_property -dict {PACKAGE_PIN U17 IOSTANDARD LVCMOS33} [get_ports {sram_data[0]}]

//////////////////////////////////32个pmod接口//////////////////////////////////////
set_property -dict {PACKAGE_PIN B16 IOSTANDARD LVCMOS33} [get_ports {exp_io[0]} ]
set_property -dict {PACKAGE_PIN A15 IOSTANDARD LVCMOS33} [get_ports {exp_io[1]} ]
set_property -dict {PACKAGE_PIN A13 IOSTANDARD LVCMOS33} [get_ports {exp_io[2]} ]
set_property -dict {PACKAGE_PIN B18 IOSTANDARD LVCMOS33} [get_ports {exp_io[3]} ]
set_property -dict {PACKAGE_PIN F13 IOSTANDARD LVCMOS33} [get_ports {exp_io[4]} ]
set_property -dict {PACKAGE_PIN B13 IOSTANDARD LVCMOS33} [get_ports {exp_io[5]} ]
set_property -dict {PACKAGE_PIN D14 IOSTANDARD LVCMOS33} [get_ports {exp_io[6]} ]
set_property -dict {PACKAGE_PIN B11 IOSTANDARD LVCMOS33} [get_ports {exp_io[7]} ]
set_property -dict {PACKAGE_PIN E15 IOSTANDARD LVCMOS33} [get_ports {exp_io[8]} ]
set_property -dict {PACKAGE_PIN D15 IOSTANDARD LVCMOS33} [get_ports {exp_io[9]} ]
set_property -dict {PACKAGE_PIN H16 IOSTANDARD LVCMOS33} [get_ports {exp_io[10]}]
set_property -dict {PACKAGE_PIN F15 IOSTANDARD LVCMOS33} [get_ports {exp_io[11]}]
set_property -dict {PACKAGE_PIN H14 IOSTANDARD LVCMOS33} [get_ports {exp_io[12]}]
set_property -dict {PACKAGE_PIN E17 IOSTANDARD LVCMOS33} [get_ports {exp_io[13]}]
set_property -dict {PACKAGE_PIN K13 IOSTANDARD LVCMOS33} [get_ports {exp_io[14]}]
set_property -dict {PACKAGE_PIN H17 IOSTANDARD LVCMOS33} [get_ports {exp_io[15]}]

set_property -dict {PACKAGE_PIN B17 IOSTANDARD LVCMOS33} [get_ports {exp_io[16]}]
set_property -dict {PACKAGE_PIN A16 IOSTANDARD LVCMOS33} [get_ports {exp_io[17]}]
set_property -dict {PACKAGE_PIN A14 IOSTANDARD LVCMOS33} [get_ports {exp_io[18]}]
set_property -dict {PACKAGE_PIN A18 IOSTANDARD LVCMOS33} [get_ports {exp_io[19]}]
set_property -dict {PACKAGE_PIN F14 IOSTANDARD LVCMOS33} [get_ports {exp_io[20]}]
set_property -dict {PACKAGE_PIN B14 IOSTANDARD LVCMOS33} [get_ports {exp_io[21]}]
set_property -dict {PACKAGE_PIN C14 IOSTANDARD LVCMOS33} [get_ports {exp_io[22]}]
set_property -dict {PACKAGE_PIN A11 IOSTANDARD LVCMOS33} [get_ports {exp_io[23]}]
set_property -dict {PACKAGE_PIN E16 IOSTANDARD LVCMOS33} [get_ports {exp_io[24]}]
set_property -dict {PACKAGE_PIN C15 IOSTANDARD LVCMOS33} [get_ports {exp_io[25]}]
set_property -dict {PACKAGE_PIN G16 IOSTANDARD LVCMOS33} [get_ports {exp_io[26]}]
set_property -dict {PACKAGE_PIN F16 IOSTANDARD LVCMOS33} [get_ports {exp_io[27]}]
set_property -dict {PACKAGE_PIN G14 IOSTANDARD LVCMOS33} [get_ports {exp_io[28]}]
set_property -dict {PACKAGE_PIN D17 IOSTANDARD LVCMOS33} [get_ports {exp_io[29]}]
set_property -dict {PACKAGE_PIN J13 IOSTANDARD LVCMOS33} [get_ports {exp_io[30]}]
set_property -dict {PACKAGE_PIN G17 IOSTANDARD LVCMOS33} [get_ports {exp_io[31]}]
```
## 单周期 RISC-V
### top
```verilog
module top(
    input clk,
    input reset,
    output wire PCSel,
    output wire MemWE
    );
wire clka;
// Design Inputs and Outputs
wire[31:0] out_inst; // 32位指令输出
wire[31:0] MemDataOut; // 从数据存储器输出的32位数据

wire[31:0] MemAddr; // 数据存储器的32位地址
wire[31:0] out_PC; // 32位程序计数器输出
wire[31:0] MemDataIn; // 写入数据存储器的32位数据

// counter_div_100M counter_div_100M(
//     .clk(clk),
//     .cnt(clka)
// );

// 实例化 RISC-V 处理器
riscv rv32(
    .clk(clk),
    .reset(reset),
    .Inst(out_inst),
    .data_in_from_mem(MemDataOut),
    .PC(out_PC),
    .mem_addr(MemAddr),
    .data_out_to_mem(MemDataIn),
    .PCSel(PCSel),
    .MemWE(MemWE)
);

// 实例化指令存储器
inst_mem im ( 
    .rst (reset),
    .addr (out_PC),
    .inst (out_inst)
);

// 实例化数据存储器
DataMem mem(
    .clk(clk),
    .rst(reset),
    .we(MemWE),
    .addr(MemAddr),
    .data_i(MemDataIn),
    .data_o(MemDataOut)
);

endmodule

```
### riscv
```verilog
module riscv(
    input wire clk, // 时钟信号
    input wire reset, // 复位信号
    input wire[31:0] Inst, // 32位指令输入
    input wire[31:0] data_in_from_mem, // 从数据存储器输入的32位数据
    
    output wire [31:0] PC, // 32位程序计数器输出
    output reg[31:0] mem_addr, // 32位内存地址输出
    output reg[31:0] data_out_to_mem, // 输出到数据存储器的32位数据
    output wire PCSel, // 程序计数器选择信号
    output wire MemWE // 内存写使能信号
);

// 控制信号和中间数据线
wire   ALUSrc1, ALUSrc2, RegWE; // ALU源1选择，ALU源2选择，寄存器写使能
wire[1:0] WBSel; // 写回选择信号
wire[31:0] Imm; // 立即数
wire[4:0]  ALUOp; // ALU操作码
wire[4:0] rs1, rs2, rd; // 源寄存器1，源寄存器2，目标寄存器
wire BrEq, BrLt; // 分支等于，分支小于信号

wire [31:0] in_ReadData1; // 从寄存器1读取的数据
wire [31:0] in_ReadData2; // 从寄存器2读取的数据

wire[4:0] ALUop_o; // ALU操作输出
wire[31:0] ALUOut; // ALU输出

wire[31:0] DataWriteBack; // 写回数据

// 实例化各个模块
// 程序计数器
PC pc (
    .clk (clk),
    .rst (reset),
    .Addr (ALUOut),
    .PCSel (PCSel),
    .PC (PC)
);

// 指令解码
ID id(
    .rst (reset),
    .inst_i (Inst),
    .PCSel (PCSel),
    .ALUSrc1 (ALUSrc1),
    .ALUSrc2 (ALUSrc2),
    .RegWE (RegWE),
    .MemWE (MemWE),
    .WBSel (WBSel),
    .Imm (Imm),
    .ALUop (ALUOp),
    .rs1 (rs1),
    .rs2 (rs2),
    .rd (rd),
    .BrEq (BrEq),
    .BrLt (BrLt)
);

// 寄存器文件
Registers reg_mem (
    .clk (clk),
    .rst (reset),
    .we (RegWE),
    .WriteAddr (rd),
    .WriteData (DataWriteBack),
    .ReadAddr1 (rs1),
    .ReadAddr2 (rs2),
    .ReadData1 (in_ReadData1),
    .ReadData2 (in_ReadData2)
);

// 分支比较
BranchComp brc(
    .rst (reset),
    .DataOutReg1(in_ReadData1),
    .DataOutReg2(in_ReadData2),
    .BrEq (BrEq),
    .BrLt (BrLt)
);

// 执行阶段
EX ex(
    .rst(reset),
    .ALUop_i(ALUOp),
    .DataOutReg1 (in_ReadData1),
    .DataOutReg2(in_ReadData2),
    .ALUSrc1 (ALUSrc1),
    .ALUSrc2 (ALUSrc2),
    .Imm(Imm),
    .PC(PC),
    .ALUop_o(ALUop_o),
    .ALUOut(ALUOut)
);

// 写回阶段
WB wb(
    .rst(reset),
    .WBSel(WBSel),
    .PC(PC),
    .ALUOut(ALUOut),
    .Data_from_mem(data_in_from_mem),
    .DataWriteToReg(DataWriteBack)
);

// 生成内存地址和数据输出
always @(*) begin
    data_out_to_mem = in_ReadData2; // 将寄存器2的数据输出到内存
end

always @(*) begin
    mem_addr = ALUOut; // 将ALU输出作为内存地址
end

endmodule

```

### if
```verilog
module PC(

	input	wire 		clk,
	input	wire		rst,
	input 	wire		PCSel,  // if branch or not
	input 	wire[31:0] 	Addr,	 // target address
	output	reg [31:0] 	PC

);

/*
 * This always part controls the signal ce.
 */
// always @ (posedge clk) begin
// 	if (rst)
// 		ce <= 1'b0;
// 	else
// 		ce <= 1'b1;
// end

/*
 * This always part controls the signal PC.
 */
 //每个时钟的上升沿
always @ (posedge clk) begin
	if (rst)
		PC <= 32'b0;
	else if (PCSel)
		PC <= Addr;
	else
		//PC <= PC + 4'h4;  // New PC equals ((old PC) + 4) per cycle.
	PC <= PC + 4;
end

endmodule
```
### inst_mem
```verilog
// 指令存储器模块
module inst_mem(
    input wire rst,        // 复位信号，用于控制模块的初始化
    input wire[31:0] addr, // 指令地址，用于从指令存储器中选择指令
    output reg [31:0] inst // 指令输出，将选定的指令传递给其他模块
);

// 定义一个32位宽、101个元素的寄存器数组作为指令存储器
reg[31:0] inst_memory[0:100];

// 初始块：在模块初始化时执行，这里用于从文件中加载机器码到指令存储器
initial $readmemb ("C:/Users/jiunian/Desktop/risc-v-singlecycle/machinecode3.txt", inst_memory); 

// 组合逻辑块：对于任何信号的变化，这个块都会执行
always @ (*) begin
    if (rst)  // 如果复位信号为高（true），则输出指令为0，表示清空或复位
        inst = 32'b0;
    else
        // 从指令存储器中获取指令，addr[31:2]是指令地址的高30位
        // 这里假设地址已经是字对齐的，即低两位为0，不用于寻址
        // 因此，直接使用高位来索引指令存储器
        inst = inst_memory[addr[31:2]]; 
end

endmodule // 模块结束


```
### id
```verilog
module ID (
    input wire rst,
    //32位宽的指令输入
    input wire[31:0] inst_i,
    //指令类型（跳转、条件分支
    input wire BrEq, BrLt,
  // 输出信号，包括PC选择、源1选择、源2选择、寄存器写使能、内存写使能
    output reg PCSel, ALUSrc1, ALUSrc2, RegWE, MemWE,
    output reg[1:0] WBSel,
    //??????
    output reg[31:0] Imm,
    //ALU??????
    output reg[4:0]  ALUop,
    output reg[4:0] rs1, rs2, rd
);
//???????????????????immediate values?????????
wire[31:0] imm_I = {{21{inst_i[31:31]}}, inst_i[30:20]};
wire[31:0] imm_B = {{20{inst_i[31:31]}}, inst_i[ 7: 7], inst_i[30:25], inst_i[11:8], 1'b0};
wire[31:0] imm_S = {{21{inst_i[31:31]}}, inst_i[30:25], inst_i[11:7]};
//???????RISC-V??????????????????????????
always @ (*) begin
    if (rst)
        PCSel = 1'b0;
    else if (inst_i[6:0] == 7'b1100111) // jarl
        PCSel = 1'b1;
    else if (inst_i[6:0] == 7'b1100011 && inst_i[14:12]  == 3'b000 && BrEq)  // beq
        PCSel = 1'b1;
    else if (inst_i[6:0] == 7'b1100011 && inst_i[14:12]  == 3'b100 && BrLt )  // blt
        PCSel = 1'b1;
    else
        PCSel = 1'b0;
end


always @ (*) begin
    if (rst)
        ALUSrc1 = 1'b0;
    else if (inst_i[6:0] == 7'b1100011)  //  beq & blt
        ALUSrc1 = 1'b1;
    else
        ALUSrc1 = 1'b0;
end

always @ (*) begin
    if (rst)
        ALUSrc2 = 1'b0;
    else if (inst_i[6:0] == 7'b0110011)  // R-type
        ALUSrc2 = 1'b0;
    else
        ALUSrc2 = 1'b1;
end

always @ (*) begin
    if (rst)
       RegWE = 1'b0;
    else if (inst_i[6:0] == 7'b0100011 || inst_i[6:0] == 7'b1100011) // S-type and B-type
       RegWE = 1'b0;
    else
       RegWE = 1'b1;
end

always @ (*) begin
    if (rst)
       MemWE = 1'b0;
    else if (inst_i[6:0] == 7'b0100011) // Store Instruction
       MemWE = 1'b1;
    else
       MemWE = 1'b0;
end

always @ (*) begin
    if (rst)
       WBSel = 2'b0;
    else if (inst_i[6:0] == 7'b0000011) //lw
       WBSel = 2'b00;
    else if (inst_i[6:0] == 7'b1100111) //jalr 
       WBSel = 2'b10;
    else //R-type, addi, output from alu
       WBSel = 2'b01;    
end

always @ (*) begin
    if (rst)
        ALUop = 5'b0;
    else begin
        casex (inst_i)

            32'bxxxxxxxxxxxxxxxxx000xxxxx1100011: ALUop = 5'b10001;  // beq
            32'bxxxxxxxxxxxxxxxxx100xxxxx1100011: ALUop = 5'b10010;  // blt
            32'bxxxxxxxxxxxxxxxxx010xxxxx0000011: ALUop = 5'b10100;  // lw
            32'bxxxxxxxxxxxxxxxxx010xxxxx0100011: ALUop = 5'b10101;  // sw
            32'bxxxxxxxxxxxxxxxxx000xxxxx0010011: ALUop = 5'b01100;  // addi
            32'b0000000xxxxxxxxxx000xxxxx0110011: ALUop = 5'b01101;  // add
            32'b0100000xxxxxxxxxx000xxxxx0110011: ALUop = 5'b01110;  // sub
            32'b0000000xxxxxxxxxx100xxxxx0110011: ALUop = 5'b00110;  // xor
            32'b0000000xxxxxxxxxx101xxxxx0110011: ALUop = 5'b01001;  // srl
            32'b0000000xxxxxxxxxx110xxxxx0110011: ALUop = 5'b00101;  // or
            32'b0000000xxxxxxxxxx111xxxxx0110011: ALUop = 5'b00100;  // and
            32'bxxxxxxxxxxxxxxxxx000xxxxx1100111: ALUop = 5'b10100;  // jalr
            default: ALUop = 5'b0;
        endcase
    end
end

always @ (*) begin
    if (rst)
        Imm = 32'b0;
    else begin
        casex (inst_i)
            32'bxxxxxxxxxxxxxxxxx000xxxxx1100011: Imm = imm_B;  // beq
            32'bxxxxxxxxxxxxxxxxx100xxxxx1100011: Imm = imm_B;  // blt
            32'bxxxxxxxxxxxxxxxxx010xxxxx0000011: Imm = imm_I;  // lw
            32'bxxxxxxxxxxxxxxxxx010xxxxx0100011: Imm = imm_S;  // sw
            32'bxxxxxxxxxxxxxxxxx000xxxxx0010011: Imm = imm_I;  // addi
            32'bxxxxxxxxxxxxxxxxx000xxxxx1100111: Imm = imm_I;  // jalr
            default: Imm = 32'b0;
        endcase
    end
end

always @ (*) begin
    if (rst)
        rd = 1'b0;
    else
        rd = inst_i[11:7];
end

always @ (*) begin
    if (rst)
        rs1 = 1'b0;
    else
        rs1 = inst_i[19:15];
end

always @ (*) begin
    if (rst)
        rs2 = 1'b0;
    else
        rs2 = inst_i[24:20];
end

endmodule
```
### BranchComp
```verilog
module BranchComp(
    input	wire	    rst,
    input   wire[31:0]  DataOutReg1,
    input   wire[31:0]  DataOutReg2,

    output reg BrEq, BrLt
);

always @(*) begin
    
    if (rst) begin
        BrLt = 1'b0;
        BrEq = 1'b0;
    end


    else  begin
        if (DataOutReg1 == DataOutReg2) begin
            BrEq = 1'b1;
            BrLt = 1'b0;
        end
        else if  (DataOutReg1 < DataOutReg2) begin
            BrEq = 1'b0;
            BrLt = 1'b1;
        end
        else begin
            BrEq = 1'b0;
            BrLt = 1'b0;
        end
    end

end
endmodule
```
### exe
```verilog
module EX(

	input	wire	    rst,
  //ALU操作码
	input	wire[4:0]   ALUop_i,
  //两个源操作数
  input   wire[31:0]  DataOutReg1,
  input   wire[31:0]  DataOutReg2,
  //选择信号，用于决定ALU的源操作数是来自寄存器还是其他
  input   wire ALUSrc1,
  input   wire ALUSrc2,

  input wire[31:0] Imm,
  //程序计数器的当前值
	input   wire[31:0]  PC,
//输出的ALU操作码
	output	wire[4:0]	ALUop_o,
  //ALU运算的结果
	output  reg[31:0] ALUOut

);
    
  assign ALUop_o   = ALUop_i;
  reg[31:0] Oprend1;
  reg[31:0] Oprend2;  

always @ (*) begin
    if (rst)
        Oprend1 = 32'b0;
    else if (ALUSrc1)
        Oprend1 = PC;
    else
        Oprend1 = DataOutReg1;
end

always @ (*) begin
    if (rst)
        Oprend2 = 32'b0;
    else if (ALUSrc2)
        Oprend2 = Imm;
    else
        Oprend2 = DataOutReg2;
end

/*
 * This always part controls the WriteData_o.
 */    
always @ (*) begin
  if (rst)
    ALUOut <= 32'b0;
  else begin
    case (ALUop_i)
      //操作码
      5'b10001: ALUOut = Oprend1 +  Oprend2; 				// beq
      5'b10010: ALUOut = Oprend1 +  Oprend2; 				// blt
      5'b10100: ALUOut = Oprend1 +  Oprend2;      // lw and jalr
      5'b10101: ALUOut = Oprend1 +  Oprend2;      // sw
      5'b01100: ALUOut = Oprend1 +  Oprend2;  		// addi
      5'b01101: ALUOut = Oprend1 +  Oprend2;  		// add
      5'b01110: ALUOut = Oprend1 -  Oprend2;  		// sub
      5'b00110: ALUOut = Oprend1 ^  Oprend2; 		  // xor
      5'b01001: ALUOut = Oprend1 >> Oprend2[4:0]; // srl
      5'b00101: ALUOut = Oprend1 |  Oprend2;  		// or
      5'b00100: ALUOut = Oprend1 &  Oprend2;  		// and
      
      default:  ALUOut = 32'b0;
    endcase
  end
end
 
endmodule

```
### data_mem
```verilog
module DataMem(
	input	wire		clk,        // 时钟信号
	input   wire        rst,        // 复位信号，用于初始化或重置数据存储器
	input	wire		we,		    // 写使能信号，为高时，允许写入数据存储器；为低时，为读取操作
	input	wire[31:0]	addr,       // 地址信号，指定访问数据存储器的地址
	input	wire[31:0]	data_i,	    // 输入数据，待写入数据存储器的数据
	output	reg [31:0]	data_o	    // 输出数据，从数据存储器读取的数据
);

	reg[7:0]  data[0:32'h400];     // 定义一个字节数组，用于存储数据存储器的内容

	// 在模块初始化时，从文件中读取数据到数据存储器
	initial $readmemh ("C:/Users/jiunian/Desktop/risc-v-singlecycle/data_mem.txt", data );

	// 在时钟上升沿，执行写操作
	always @ (posedge clk) begin
		if (!rst && we) begin    // 当复位信号为低且写使能为高时，执行写操作
			data[addr]     <= data_i[7:0];       // 写入最低有效字节
			data[addr + 1] <= data_i[15:8];      // 写入次低有效字节
			data[addr + 2] <= data_i[23:16];     // 写入次高有效字节
			data[addr + 3] <= data_i[31:24];     // 写入最高有效字节

			// 打印写入的数据信息
			$display("Byte 0x%h = %d", addr, data_i); 
		end
	end

	// 读取数据操作
	always @ (*) begin
		if (rst) // 当复位信号为高时，输出数据清零
			data_o = 32'b0;
		else if(we == 1'b0) begin // 当写使能为低时，执行读操作
			data_o = {
						data[addr + 3],
						data[addr + 2],
						data[addr + 1],
						data[addr]   
					  }; // 读取数据并按小端序组装
		end 
		else
			data_o = 32'b0; // 若非读操作，则输出数据清零
	end		

endmodule

```

### wb
```verilog
module WB (
    input rst,
    //写回选择信号，决定了写回到寄存器的数据来源
    input   wire[1:0]       WBSel,
    input   wire[31:0] PC,
    input   wire[31:0] ALUOut,
    input   wire[31:0]  Data_from_mem,
    output  reg[31:0]  DataWriteToReg
);

always @ (*) begin
    if (rst)
        DataWriteToReg <= 32'b0;
    else if (WBSel == 2'b0)
        DataWriteToReg <= Data_from_mem;
    else if (WBSel == 2'b01)
        DataWriteToReg <= ALUOut;
    else if (WBSel == 2'b10)
        DataWriteToReg <= PC + 4;
end

endmodule
```
### register
```verilog
 module Registers(

    input   wire        clk,
    input   wire        rst,
    input   wire        we,
    input   wire[4:0]   WriteAddr,
    input   wire[31:0]  WriteData,
    input   wire[4:0]   ReadAddr1,
    input   wire[4:0]   ReadAddr2,
    output  reg [31:0]  ReadData1,
    output  reg [31:0]  ReadData2

    );


    reg [31:0] regFile [0:31];

/*
 * This always part controls the regFile, it's a 32*32 reg.
 */

//initial $readmemb ("./RISC-V-SingleCycle/reg_mem.txt", regFile);    

always @ (posedge clk) begin
    regFile[5'h0] <= 32'b0;  // Register x0 always equals 0. 
    if (rst) begin
        regFile[5'b00001] <= 32'b0;
        regFile[5'b00010] <= 32'b0;
        regFile[5'b00011] <= 32'b0;
        regFile[5'b00100] <= 32'b0;
        regFile[5'b00101] <= 32'b0;
        regFile[5'b00110] <= 32'b0;
        regFile[5'b00111] <= 32'b0;
        regFile[5'b01000] <= 32'b0;
        regFile[5'b01001] <= 32'b0;
        regFile[5'b01010] <= 32'b0;
        regFile[5'b01011] <= 32'b0;
        regFile[5'b01100] <= 32'b0;
        regFile[5'b01101] <= 32'b0;
        regFile[5'b01110] <= 32'b0;
        regFile[5'b01111] <= 32'b0;
        regFile[5'b10000] <= 32'b0;
        regFile[5'b10001] <= 32'b0;
        regFile[5'b10010] <= 32'b0;
        regFile[5'b10011] <= 32'b0;
        regFile[5'b10100] <= 32'b0;
        regFile[5'b10101] <= 32'b0;
        regFile[5'b10110] <= 32'b0;
        regFile[5'b10111] <= 32'b0;
        regFile[5'b11000] <= 32'b0;
        regFile[5'b11001] <= 32'b0;
        regFile[5'b11010] <= 32'b0;
        regFile[5'b11011] <= 32'b0;
        regFile[5'b11100] <= 32'b0;
        regFile[5'b11101] <= 32'b0;
        regFile[5'b11110] <= 32'b0;
        regFile[5'b11111] <= 32'b0;
    end
//?????????????????д???????
    if (!rst && we && WriteAddr != 5'h0) begin
        regFile[WriteAddr] <= WriteData;  // Write data to register.
        $display("x%d = %d", WriteAddr, WriteData);  // Display the change of register.
    end
end

/*
 * This always part controls the signal ReadData1 as rs1. 
 */ 
 //??????????ж???????ReadData1??
always @ (*) begin
    if (rst || ReadAddr1 == 5'h0)
        ReadData1 = 32'b0;
    else 
        ReadData1 = regFile[ReadAddr1];

end

/*
 * This always part controls the signal ReadData2 as rs2.
 */ 
 //??????????ж???????ReadData2??
always @ (*) begin
    if (rst || ReadAddr2 == 5'h0)
        ReadData2 = 32'b0;
    else 
        ReadData2 = regFile[ReadAddr2];
end
    
endmodule
```

## 单周期 mips
### mips
```verilog
module mips(clk, reset);
//main cpu module

input clk;
input reset;

wire [5:0] OpCode;

wire [1:0] ALUOp;

wire RegDst;
wire ALUSrc;
wire MemToReg;
wire RegWrite;
wire MemRead;
wire MemWrite;
wire Branch;

datapath Datapath(clk,reset,RegDst,ALUSrc,MemToReg,RegWrite,MemRead,MemWrite,Branch,ALUOp,OpCode);

control Control(OpCode,RegDst,ALUSrc,MemToReg,RegWrite,MemRead,MemWrite,Branch,ALUOp); 

endmodule

```

### control
```verilog
module control(opcode, RegDst, ALUSrc, MemtoReg, RegWrite, MemRead, MemWrite, Branch, AluOP);

input [5:0] opcode;

output reg RegDst;
output reg ALUSrc;
output reg MemtoReg;
output reg RegWrite;
output reg MemRead;
output reg MemWrite;
output reg Branch;

output reg [1:0] AluOP;

always @(opcode) begin
	case (opcode)
		6'b000000:{RegDst, ALUSrc, MemtoReg, RegWrite, MemRead, MemWrite, Branch, AluOP}=9'b100100_0_10; //r
		6'b100011:{RegDst, ALUSrc, MemtoReg, RegWrite, MemRead, MemWrite, Branch, AluOP}=9'b011110_0_00; //lw
		6'b101011:{RegDst, ALUSrc, MemtoReg, RegWrite, MemRead, MemWrite, Branch, AluOP}=9'bx1x001_0_00; //sw
		6'b000100:{RegDst, ALUSrc, MemtoReg, RegWrite, MemRead, MemWrite, Branch, AluOP}=9'bx0x000_1_01; //beq
		default:
	{RegDst,ALUSrc,MemtoReg,RegWrite,MemRead,MemWrite,Branch,AluOP}=9'bxxx_xxx_x_xx;
	endcase
end

endmodule

```

### datapath
```verilog
module datapath(clk, reset, RegDst,AluSrc,MemtoReg,RegWrite,MemRead,MemWrite,Branch,ALUOp,OpCode);

input clk;
input reset;

input RegDst,AluSrc,MemtoReg,RegWrite,MemRead,MemWrite,Branch;

wire [31:0] Instruction;

input [1:0] ALUOp;
wire [3:0] ALUCtrl;
wire [31:0] ALUout;
wire Zero;

output [5:0] OpCode;
assign OpCode = Instruction[31:26];

wire [31:0] PC_adr;

wire [31:0] ReadRegister1;
wire [31:0] ReadRegister2;

wire [4:0] muxinstr_out;
wire [31:0] muxalu_out;
wire [31:0] muxdata_out;

wire [31:0] ReadData;

wire [31:0] signExtend;

wire PCsel;

mem_async meminstr(PC_adr[7:0],Instruction); //Instruction memory
mem_sync memdata(clk, ALUout[7:0], ReadData, ReadRegister2, MemRead, MemWrite); //Data memory
rf registerfile(clk,RegWrite,Instruction[25:21],Instruction[20:16],muxinstr_out, ReadRegister1, ReadRegister2, muxdata_out); //Registers

alucontrol AluControl(ALUOp, Instruction[5:0], ALUCtrl); //ALUControl
alu Alu(ReadRegister1, muxalu_out, ALUCtrl, ALUout, Zero); //ALU

pclogic PC(clk, reset, signExtend, PC_adr, PCsel); //generate PC
andm andPC(Branch, Zero, PCsel); //AndPC (branch & zero)
signextend Signextend(signExtend, Instruction[15:0]); //Sign extend

mux #(5) muxinstr(RegDst, Instruction[20:16],Instruction[15:11],muxinstr_out);//MUX for Write Register
mux #(32) muxalu(AluSrc, ReadRegister2, signExtend, muxalu_out);//MUX for ALU
mux #(32) muxdata(MemtoReg, ALUout, ReadData, muxdata_out); //MUX for Data memory



endmodule

```

### mem_async (rom)
```verilog
module mem_async(a,d);
//asynchronous memory with 256 32-bit locations
//for instruction memory
parameter S=32;
parameter L=256;

input [$clog2(L) - 1:0] a;
output [(S-1):0] d;

reg [S-1:0] memory [L-1:0];
assign d=memory[a];

initial $readmemh("meminstr.dat", memory);

endmodule

```

### mem_sync (ram)
```verilog
module mem_sync(clk,a,dout, din, mread, mwrite);
//synchronous memory with 256 32-bit locations
//for data memory
parameter S=32; //size
parameter L=256; //length

input [$clog2(L) - 1:0] a;
input [S-1:0] din;
input clk;
input mwrite;
input mread;
output [(S-1):0] dout;

reg [S-1:0] memory [L-1:0];

assign dout=memory[a];

always @(posedge clk) begin
	if (mwrite==1) begin
		memory[a]<=din;
	end
end


initial $readmemh("memdata.dat", memory);

endmodule

```

### registerfile
```verilog
module rf(clk,RegWrite,ra,rb,rc,da,db,dc);
input clk;
input RegWrite;
input [4:0] ra; //read register 1 (instr 25-21)
input [4:0] rb; //read register 2 (instr 20-16)
input [4:0] rc; //write register (out mux instr)
input [31:0] dc; //write data (out mux data)
output [31:0] da; // read data 1
output [31:0] db; // read data 2

reg [31:0] memory [31:0]; //32 32-bit registers

assign da=(ra!=0)?memory[ra]:0;
assign db=(rb!=0)?memory[rb]:0;

always@(posedge clk)begin
	if(RegWrite==1'b1)begin
		memory[rc]<=dc;
	end
end
endmodule

```

### alucontrol
```verilog
module alucontrol(AluOp,FnField,AluCtrl);

input [1:0] AluOp;
input [5:0] FnField; //for R-type instructions

output reg [3:0] AluCtrl;


always@(AluOp or FnField)begin
	casex({AluOp,FnField})
		8'b00_xxxxxx:AluCtrl=4'b0010; //lw / sw
		8'b01_xxxxxx:AluCtrl=4'b0110; //beq
		8'b1x_xx0000:AluCtrl=4'b0010; //add
		8'b1x_xx0010:AluCtrl=4'b0110; //sub
		8'b1x_xx0100:AluCtrl=4'b0000; //and
		8'b1x_xx0101:AluCtrl=4'b0001; //or
		8'b1x_xx1010:AluCtrl=4'b0111; //slt
	endcase
end

endmodule

```

### alu
```verilog
module alu(opA, opB, ALUop, result, zero);

input [31:0] opA;
input [31:0] opB;
input [3:0] ALUop;

output reg [31:0] result;
output zero; //1 if result is 0

assign zero = (result==0);

always @(ALUop, opA, opB) begin
	case(ALUop)
		4'b0000: result=opA&opB;
		4'b0001: result=opA|opB;
		4'b0010: result=opA+opB;
		4'b0110: result=opA-opB;
		4'b0111: result=opA<opB?1:0; //slt
		4'b1100: result=~(opA|opB);
	endcase
end

endmodule

```

### pclogic
```verilog
module pclogic(clk, reset, ain, aout, pcsel);

input reset;
input clk;
input [31:0] ain;
//pecsel = branch & zero
input pcsel;

output reg [31:0] aout;

always @(posedge clk ) begin
	if (reset==1)
		aout<=32'b0;
	else
		if (pcsel==0) begin
			aout<=aout+1;
		end
		if (pcsel==1) begin
			aout<=ain+aout+1; //branch
	end
end


endmodule

```

### andm
```verilog
module andm (inA, inB, out);
//1 bit and for (branch & zero)
input inA, inB;
output out;

assign out=inA&inB;

endmodule

```

### signextend
```verilog
module signextend (out,  in ) ;
output [31 : 0]  out;
input [15 : 0]  in ;
assign out ={{16 {in [ 15 ]}},in};
endmodule
```

### mux
```verilog
module mux(sel, ina, inb, out);
//mux 2 to 1
parameter DATA_LENGTH = 8;

input sel;
input [DATA_LENGTH-1 : 0] ina; 
input [(DATA_LENGTH-1) : 0]  inb;
output [DATA_LENGTH-1 : 0] out;

assign out=(sel==0)?ina:inb;

endmodule
```