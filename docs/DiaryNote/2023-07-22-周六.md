# Makefiles
> [!note] 依赖图
> ![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230722083150.png)
> 任何的文件被修改了，文件将会被重新编译
## 内置函数
[Functions (GNU make)](https://www.gnu.org/software/make/manual/html_node/Functions.html)
### 字符串替换
- `$(parsubst pattern, replacement, text)`：在于`pattern`匹配的`text`中查找空格分隔的单词，并将其替换为`replacement`

### foreach
- `$(foreach var, list, text)`：将一个单词列表转换为另一个列表
	- `var`被设置为list中每个单词
	- `text`是针对每一个单词的展开
```makefile
foo := who are you
bar := $(foreach wrd, $(foo), $(wrd)!)
```

### if
- if检查第一个参数是否为非空
	- `true`：运行第二个参数
	- `false`：运行第三个参数
 ```makefile
 foo := $(if this-is-not-empty,then!,else!) 
 empty := 
 bar := $(if $(empty),then!,else!) 
 all: 
	 @echo $(foo) 
	 @echo $(bar)
```

### 函数调用
### shell函数
## 其他规则
### 隐式规则
- 隐含规则的列表：
	- 编译C程序：`$(CC) -c $(CPPFLAGS) $(CFLAGS)`
	- 编译C++程序：`$(CXX) -c $(CPPFLAGS) $(CXXFLAGS)`
	- 连接单个目标文件：`$(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS)`
- 隐式规则使用的变量
	- `CC`：编译C程序的程序；默认为`cc`
	- `CXX`：编译C++程序的程序；默认为`gcc`
	- `CFLAGS`：提供给C编译器的额外标志
	- `CXXFLAGS`：提供给C++编译器的额外标志
	- `CPPFLAGS`：提供给C预处理器的额外标志
	- `LDFLAGS`：当编译器应该调用链接器时，提供的额外标志

### 静态模式规则
- 静态模式规则是在Makefile中减少编写量的另一种方式：
```makefile
targets... : target-pattern : prereq-patterns ..
	commands
```
- 本质：给定`target`与`target-pattern`匹配
```makefile
objects = foo.o bar.o all.o
all: $(objects)

# foo.o : foo.c
# bar.o : bar.c
# all.o : all.c
$(obejcts) : %.o : %.c

all.c :
	echo "int main() {return 0;}" > all.c

%.c :
	touch $@

clean:
	rm -f *.c *.o*
```
---

# 计算机系统的状态机模型
> [!note] 状态机模型
> - 状态集合S
> - 激励事件E
> - 状态转移规则next
> - 初始状态
> ![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20230722150200.png)
- 计算机系统
## 程序
- C语言的组成：
	- 变量：计算的对象
	- 语句：计算的操作流程
	- 输入输出函数：让变量与外界交互
- C程序的状态机模型
	- 状态集合$S=\{<V, PC>\}$
	- 激励事件$E=\{语句\}$
	- 状态转移规则：语句的语义
	- 初始状态$S_0=<V_0, main函数的第一条语句>$
## CPU
- CPU的状态机模型：
	- 状态集合$S=\{<时序逻辑元件的值>\}$
	- 激励事件$E=\{组合逻辑\}$
	- 状态转移规则next：$S\times E \rightarrow S$
		- 语句的语义
		- 由设计中的组合逻辑电路决定
		- 依据：架构师的设计文档
	- 初始状态$S_0=<复位时时序逻辑元件的值>$
## 指令集
- 指令集是一本手册规范：定义了CPU执行指令的行为
	- 好比：C语言标准手册定义了C程序执行语句的行为
- 指令集状态机：
	- 状态机和$S=\{<R,M>\}$
		- R寄存器
		- M内存
	- 激励事件$E=\{指令\}$
	- 状态转移规则next：$S\times E \rightarrow S$
	- 初始状态$S_0=<R_0, M_0>$
## 程序如何在计算机上运行
### 编译
- 编译器的工作：将C程序的状态机$S_C$翻译为指令集的状态机$S_{ISA}$
	- $s_{compile}: \left\{ PC_{c},v_{1},v_{2},v_{3}, \ldots \right\} \rightarrow \left\{ R,M \right\}$
	- $e_{compile}: \{语句\} \rightarrow \{指令序列\}$
	- $next:S\times E \rightarrow S$使得

### CPU结构设计
- CPU结构设计的工作：根据指令集的状态机$R_{ISA}$用电路实现CPU的状态机$S_{CPU}$
	- $S_{arch}:\{R,M\}\rightarrow \{时序逻辑电路\}$
	- $e_{arch}:\{E\}\rightarrow \{时序逻辑电路\}$

### 程序如何在计算机上运行
- 结构设计：根据指令集手册的功能描述，画一张CPU的电路图
- RTL设计：用RTL代码描述CPU电路图
- 后端物理设计：根据RTL代码生成版图文件
- 制造生产：根据版图文件生产芯片
- 软件编程：编写程序
- 编译：将程序翻译成指令集手册中描述的指令序列
- 程序在CPU上执行->指令序列控制CPU芯片电路进行状态转移
	- 使得三个状态机产生联系：$S_C\sim S_{isa}\sim S_{cpu}$

## 总结
$$\begin{array}{cccc} 
& \text { 程序 } & \text { 抽象计算机 } & \text { CPU } \\
\hline \text { 状态 } & \{<V, P C>\} & \{<R, M>\} & \text { \{时序逻辑电路 } \\
\hline \text { 状态转移规则 } & \text { C语言语句的语义 } & \text { 指令的语义 } & \text { 组合逻辑电路 } \\
\hline \mathrm{FM} & \text { C语言标准手册 } & \text { 指令集手册 } & \text { 架构设计文档 }
\end{array}$$
- 程序编译：将语句翻译成语义等价的指令序列
- 结构设计：按照指令语义设计行为等价的登录
- 程序运行：指令序列驱动电路进行状态转移

---
- 无论什么时候运行C程序并且使它工作，都应该使用`Valgrind`重新运行它来检查
- 对于得到的每个错误，找到“源码：行数”提示的位置，然后修复它
	- 可以上网搜索错误信息，来弄清楚它的意思
- 直到程序在`Valgrind`中不出现任何错误信息