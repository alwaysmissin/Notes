# 嵌入式系统原理

# 概述

## 概念

- 嵌入式系统是“控制、监视或者辅助设备、机器和
  车间运行的装置”——IEEE的定义
- 嵌入式系统是嵌入到对象体系中的、用于执行独
  立功能的专用计算机系统

![image-20230413161306025](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413161306025.png)



## 嵌入式系统和桌面通用系统的区别

- 运行任务：
  - 专用而确定
- 实时性要求高
  - ![image-20230413161516347](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413161516347.png)
- 可靠性要求高
- 功耗约束
- 内核小
  - ![image-20230413161547514](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413161547514.png)

- 需要专用工具和特殊方法
  - 开发
    - 交叉编译，交叉链接

  - 调试
    - 仿真器，虚拟机

  - 更新
    - 在线更新


## 结构

![image-20230413161705532](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413161705532.png)

![image-20230413161722394](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413161722394.png)

![image-20230413161736476](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413161736476.png)

![image-20230413161750496](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413161750496.png)

# ARM微处理器

## 微处理器概念

### 计算机系统结构

冯诺依曼与哈佛结构

- 冯诺依曼
  - 指令数据同时只能取一

- 哈佛
  - 并行指令，同时执行
  - 可以同时取指令与数据

![image-20230413161926820](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413161926820.png)

![image-20230413161938014](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413161938014.png)

![image-20230413162102744](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413162102744.png)

### 指令集

![image-20230413162155008](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413162155008.png)

- **RISC：精简指令集**
  - 借助一些可以在单个CPU周期完成的指令，以降低CPU的复杂度，将程序的复杂性交给编译器。
  - 只包含最有用的操作
  - **load-store结构**
    - **CPU**：CPU只处理寄存器中的数据，使用Load/Store指令来完成数据在寄存器和外部存储器之间的传送。
  
- **CISC：复杂指令集**
  - **用最少的机器语言指令来完成所需的计算任务**。
  - **包括大量具有复杂功能的指令和丰富的寻址方式**。
  - 8/2原则：常用指令仅占指令总数的20％，但在程序中出现的频度却占80％
  - 大多数程序只使用少量的指令就能够运行。
  - CPU包括丰富的单元电路→功能强、面积大、价格高、功耗大，这与嵌入式系统要求相悖


![image-20230413162511097](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413162511097.png)

![image-20230413162523586](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413162523586.png)

![image-20230413162535449](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413162535449.png)

![image-20230413162602297](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413162602297.png)

**Gpt：**

- CISC是一种将琐碎的步骤实现集成到了CPU内部的指令集，例如Intel的SSE3和AMD的3DNow!。CISC处理器必须对不等长指令进行分割，因此在执行单一指令的时候需要进行较多的处理工作。
- RISC执行的是等长精简指令集，CPU在执行指令的时候速度较快且性能稳定。因此在并行处理方面RISC明显优于CISC，RISC可同时执行多条指令，它可将一条指令分割成若干个进程或线程，交由多个处理器同时执行。由于RISC执行的是精简指令集，所以它的制造工艺简单且成本低廉。

#### 注意：

- **哈佛、冯诺依曼结构与指令系统没有严格的对应关系**



### 流水线技术

几条指令可以并行执行

![image-20230413162709723](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413162709723.png)

## ARM概述

Advanced RISC Machines

## ARM结构

![image-20230413162822630](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413162822630.png)

外部设备——外围设备

- 在ARM架构中，外部设备和外围设备的区别在于
- 外部设备：
  - 外部设备通常指的是与**ARM处理器通过总线**（如数据总线、地址总线、控制总线）**相连的设备**。
  - 外部设备可以是**存储器芯片（如闪存、RAM）、外部接口（如UART、SPI、I2C）、传感器、显示器**等。
  - 它们是通过总线进行数据传输和控制信号的交互。是指与CPU相连的外部存储器，如RAM、ROM、Flash等
- 外围设备：
  - 外围设备是指**与ARM处理器相连的外部硬件模块或接口，用于扩展ARM处理器的功能和连接外部设备。**
  - 外围设备包括各种控制器和接口，如**DMA控制器、定时器、GPIO（通用输入输出）接口、以太网控制器、USB控制器等。**
  - 它们与ARM处理器通过总线或专用接口相连，用于处理特定的输入输出任务。

## 运行模式

![image-20230413162909215](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413162909215.png)

### 分类

#### 用户模式和特权模式

![image-20230413163049997](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413163049997.png)

- 用户模式：
  - **大多数应用程序**运行在用户模式
  - **不能访问被保护的系统资源**
  - 不能**直接切换**到其他特权模式，可以用**产生异常，在异常处理中实现模式切换**
- 特权模式：
  - 程序可以**访问所有系统资源**
  - **任意进行处理器模式的切换**

#### 异常模式

![image-20230413163304175](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413163304175.png)

异常模式：

- 用于处理异常（包括中断）和访问受保护的系统资源

#### 用户和系统模式

- **不能由异常直接进入**，使用完全相同的寄存器组
- 系统模式：
  - OS在该模式 下可以访问用户模式的寄存器
  - 特权任务可以使用该模式访问一些受控的资源

### 模式切换

- 运行模式：
  - **直接、间接通过程序**切换进入
- 特定的**异常出现**时，处理器进入相应的模式

![image-20230413163729712](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413163729712.png)

## 工作状态

### ARM与Thumb

![image-20230413163754432](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413163754432.png)

- ARM状态
  - 固定宽度：**32位，4字节对齐**
  - 有限的存储空间中，存放的指令少，代码密度低
- Thumb状态
  - 指令长度被压缩：**16位，2字节**
  - **只支持一些通用功能**，不是一套完整的指令体系
  - **可看做ARM指令压缩形式的子集**
  - 必要时仍需要ARM指令集支持。

### 区别

![image-20230413164028252](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413164028252.png)

### 切换模式

#### 切换到Thumb

- 当**寄存器Rm的状态位bit[0]=1时**
  - 可以通过执行“BX Rm”指令,使微处理器从ARM状态→Thumb状态。
- 当处理器处于Thumb状态时，若**发生异常**（如IRQ、FIQ、Undef、Abort、SWI等
  - 则**异常处理返回**时，自动切换到Thumb状态

![image-20230413164249128](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413164249128.png)

#### 切换到ARM

- 当**寄存器Rm的状态位bit[0]=0时**，可以通过执行“BX Rm”指令,使微处理器从Thumb状态→ARM状态。
- 在处理器**进行异常处理**时，默认将处理器切换到ARM

![image-20230413165156807](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413165156807.png)



## 寄存器组织

### 通用寄存器

#### 未分组寄存器

##### R0-R7

![image-20230413170339792](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413170339792.png)

#### 分组寄存器

##### R8-R14

![image-20230413170427293](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413170427293.png)

![image-20230413170451380](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413170451380.png)

##### R13——堆栈指针

- ARM：堆栈指针
- Thumb：某些指令强制要求使用R13作为堆栈指针
- **每种运行模式都有自己独立的物理寄存器R13**，故在初始化时，需要初始化每种模式对应的R13

![image-20230413170644139](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413170644139.png)

##### R14——子程序链接寄存器

- R14寄存器也被称为Link Register**（LR）**
- 当执行**子程序调用指令BL时**，可以用于得到**程序计数器PC(R15)**的备份
  - BL指令（Branch and Link）
- 其他情况下作为通用寄存器
- 特殊功能：
  - 在每种模式下都可以用于**保存子程序的返回地址**。
  - 发生异常时，用于**保存异常处理后的返回地址**，如中断处理等。

##### R14例：

![image-20230413171016426](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413171016426.png)

- 程序A执行过程中调用程序B
- 执行到“BL Lable”时：
  - **将下一条指令所在地址存入R14**
  - 跳转至程序B
- 执行程序B到最后：
  - **将R14寄存器内容放入PC，返回程序A**
    - MOV PC LR 

##### R14注意：

![image-20230413171823856](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413171823856.png)

![image-20230413171931038](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413171931038.png)

#### 程序计数器

PC（R15）

- 所有七种运行模式下，都指向一个物理寄存器。
- ARM状态：bit[1:0]=00，bit[31:2]用于存放PC
  - **PC的值=当前正在执行指令的地址值+8。**
    - **PC总是指向当前正在执行指令的下两条指令**
    - 原因：ARM采用多级**流水线技术**
- Thumb状态：bit[0]=0，bit[31:1]用于存放PC

### 状态寄存器

#### CPSR和SPSR

- 当前程序状态寄存器CPSR (Current Program Status Register)
  - 所有运行模式下都指向相同的物理寄存器。可在任何运行模式下被访问
- 备份程序状态寄存器SPSR (Saved Program Status Register)
  - 每种异常模式都有自己的专用物理寄存器。
  - 异常发生时，保存CPSR；异常退出时用于恢复CPSR
  - 用户模式和系统模式下无效（访问时结果未知）

![image-20230413172316342](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413172316342.png)

#### 条件码标志位

- **N、Z、C、V标志位：**
  - 它们的内容由算术或逻辑运算的结果决定，通常用于决定某条指令是否可以被执行。
- ARM状态：绝大多数的指令都是有条件执行的。
- Thumb状态：仅有分支指令（B指令）是有条件执行的

![image-20230413172504776](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413172504776.png)

类比8086汇编的标志

- C
  - 进位和借位不同

#### 保留位

- 为了提高程序的可移植性，当改变CPSR标志和控制位时，尽量不要改变保留位的值。

- 为了保证程序后续的兼容性，不要让保留位的值影响程序运行

#### 控制位

![image-20230413172556556](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413172556556.png)

![image-20230413172604536](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413172604536.png)





## 存储器格式

### 存储格式

从零地址开始**字节线性组合**

- 0-3：第一个存储的字数据
- 4-7：第二个存储的字数据
- ![image-20230501091853103](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230501091853103.png)

#### 大端格式

高字节——低地址

低字节——高地址

![image-20230501092004286](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230501092004286.png)

#### 小端格式

高字节——高地址

低字节——低地址

![image-20230501092110685](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230501092110685.png)

### 内存管理（*）

#### MMU

![image-20230501092317706](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230501092317706.png)

![image-20230501092329504](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230501092329504.png)

![image-20230501092411911](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230501092411911.png)

#### 分页式存储管理

- 把虚拟存储空间分成固定大小的**页**
- 把物理主存储的空间也分成同样大小的**页框**
- 通过**查询页表**，
  - 实现**虚拟地址——物理地址 转换**
- 采用**快表技术（TLB）**提高地址转换速率

#### TLB

- 微处理器访问主存时，首先根据虚拟地址在TLB中查找对应的转换条目
  - 如果**存在(命中，Hit)，则直接转换**
  - 如果**不存在，则继续在位于主存的页表中查找，并把查找到结果(地址转换条目)添加到TLB中**。——TLB更新
  - 在添加时，如果TLB已满，可根据一定的淘汰算法进行替换



#### 映射单位

- 虚拟存储空间到物理存储空间的映射是以**存储块**(Memory Block)为单位进行的
- 在页表/TLB中，每个Entry记录了一个虚拟存储空间的存储块的基地址与物理存储空间的一个存储块的基地址的对应关系

![image-20230501093413226](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230501093413226.png)



#### 存储块类型（*）

##### 一级页表

![image-20230501093453488](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230501093453488.png)

![image-20230501093554115](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230501093554115.png)

![image-20230503220428348](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230503220428348.png)

##### 二级页表

![image-20230503220501706](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230503220501706.png)

![image-20230503220518431](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230503220518431.png)

![image-20230503220540673](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230503220540673.png)

#### 地址转换过程（*）

- 给定的虚拟地址**查找一级页表**
- 若该条目是**段描述符：**
  - 则返回物理地址，转换结束。——**单步搜索**
- 若该条目是**粗页表目录项**：
  - 则继续利用虚拟地址查找二级粗页表，获得大页描述符或小页描述符，返回物理地址，转换结束。——**两步搜索**
- 若该条目是**细页表目录项**：
  - 则继续利用虚拟地址查找二级细页表，获得大页、小页或极小页描述符，返回物理地址，转换结束。——**两步搜索**
- 其它情况出错

![image-20230503220726750](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230503220726750.png)

##### **页表基址寄存器**（TTB）：

![image-20230503234506828](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230503234506828.png)

**TTB base代表一级页表地址**，将它写入协处理器CP15的寄存器C2（称为页表基址寄存器）

一级页表的地址必须是16K对齐的（位[14:0]为0），一级页表中使用4096个描述符来表示这4G空间，每个描述符对应1M的虚拟地址

- 要么存储了他对应的1M物理空间的起始地址
- 要么存储了下一级页表的地址，使用虚拟地址MVA[31：20]进行引索（2的12次方正好为4096）

##### 转换的虚拟地址（MVA）：

![image-20230503234547909](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230503234547909.png)

##### 定位一级页表

页表基址寄存器（TTB）位**[31:14]和MVA[31:20]**组成一个低两位为0的**32位地址**

MMU**利用这个地址找到描述符**

![image-20230503234946253](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230503234946253.png)

##### 单步搜索—段方式

![image-20230503235031949](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230503235031949.png)

- 当一级描述符的**最低两位为10**时表示段
- **段描述符[31:20]称为段基址**
  - **此描述符的低20位填充0后就是一块1MB的物理地址空间的起始地址**
  - **使用MVA[19:0]在这1MB来引索**
- 所以，**描述符的位[31:20]和MVA[19:0]就构成了这个虚拟地址MVA对应的物理地址**  
- 过程：
- 1：页表基址寄存器（TTB）**位[31:14]和MVA[31:20]**组成一个低两位为0的**32位地址，MMU利用这个地址找到段描述符**  
- 2：**取出段描述符的 [31:20]，即段基址**，它**和MVA[19:0]组成一个32位的物理地址**，这就是虚拟地址

##### 两步搜索—粗页表

![image-20230503235604354](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230503235604354.png)

粗页表映射： 当一级描述符的最低两位为01时表示是粗页表

- 粗页描述符[31：10]称为粗页表基址
  - 此描述符的低10位填充0后就是一个二级页表的物理地址
  - 此二级描述符含有**256**个条目，用MVA[19:12]来引索
  - 所以此二级描述符含256个描述符（19-12+1=8,2的8次方正好等于256），每个描述符占4个字节，所以粗页表大小为1KB，其中每个描述符表示大小为4KB的物理地址，所以一个粗页表表示1MB的物理地址

##### 大页映射

![image-20230503235922711](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230503235922711.png)

当二级描述符（粗页或细页）的最低两位为01时表示大页：

- **MVA[31:16]称为大页基址**
  - 此描述符低16位填充0后就是一块64KB物理地址空间的起始地址，粗页表中每个描述符只能保存表示的物理空间
- 过程：
  - 1：页表基址寄存器（TTB）位**[31:14]和MVA[31:20]**组成一个低两位为0的32位地址，MMU利用这个地址找到**粗页表描述符**
  - 2：**取出粗页地址描述符的位[31:10]，即粗页表基址**，它和**粗页引索MVA[19:12]**组成低两位为0的**32位物理地址，据此即可找到大页描述符**
  - 3：取出**大页描述符的位[31:16]，即大页基址**，它和**大页引索MVA[15:0]组成一个32位的物理地址，这就是虚拟地址对应的物理地址**







页表末两位：0 0:32位——30位

![image-20230413092219597](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230413092219597.png)



#### CP15

![image-20230504000329565](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504000329565.png)

##### 寄存器

![image-20230504000336001](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504000336001.png)

##### 使能MMU

![image-20230504000422150](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504000422150.png)

![image-20230504000433854](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504000433854.png)

##### 注意：

- 使能MMU之前，要在主存中建立页表，同时CP15相关，寄存器必须完成初始化。
- 若设计的物理地址空间与虚拟地址空间不相等，则在禁止/使能MMU时，虚拟地址和物理地址的对应关系会改变，故应清除Cache中当前地址转换条目。
- 完成禁止/使能MMU程序，其物理地址最好与虚拟地址相同，否则禁止/使能MMU将带来很大麻烦。

##### 存储访问权限控制

![image-20230504000526487](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504000526487.png)

##### 域

![image-20230504000559398](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504000559398.png)

##### 储存访问失效

![image-20230504000635340](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504000635340.png)

![image-20230504000650254](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504000650254.png)

![image-20230504000655948](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504000655948.png)



### 异常处理

#### 程序执行流程

- 正常执行：
  - 每执行一条**ARM**指令，程序计数器寄存器**(PC)的值加4个字节**；
  - 每执行一条**Thumb**指令，**PC的值加2个字节**。
  - 整个过程按顺序执行。

- 通过跳转指令(B、BL、BLX和BX)，程序可以跳转到特定的位置处(地址标号、子程序等）执行

- 正常的程序执行流程发生暂时的停止，称之为异常
  - 例如：处理一个外部的中断请求。

#### 异常处理过程

![image-20230504000908215](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504000908215.png)

![image-20230504000940144](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504000940144.png)

- 异常向量地址：
  - 异常出现后，强制从**异常类型对应的固定地址**开始执行程序
- 异常向量表：
  - 由七个异常向量及其异常处理函数跳转关系组成的表。
  - 每个异常向量**占4个字节**。**（★表现为一条跳转指令）**

![image-20230504001106549](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504001106549.png)

##### 具体步骤

![image-20230504001643866](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504001643866.png)

![image-20230504001654061](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504001654061.png)

#### 异常返回过程（*）

![image-20230504001740123](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504001740123.png)

![image-20230504001820150](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504001820150.png)

- PABT和DABT：
  - 减8原因：
    - 数据中止异常是在数据访问指令执行时发生的
    - **而PC寄存器此时已经指向下一条指令，**
    - 所以要**回退两条指令，即PC-8**才能返回到异常发生前的状态。

![image-20230504002602829](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230504002602829.png)







# ARM指令集

## 寻址方式

### 指令格式

- 操作数
- 操作码

![image-20230505212822593](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505212822593.png)

### 具体方式：

**(1) 寄存器寻址** 

**(2) 立即寻址**

**(3) 寄存器偏移寻址** 

**(4) 寄存器间接寻址**

**(5) 基址寻址** 

**(6)** **多寄存器寻址**

**(7) 堆栈寻址** 

**(8) 相对寻址**

### 寄存器寻址

指令中操作数给出的是**寄存器编号**

指令执行时直接取出寄存器的值来操作

![image-20230505212920398](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505212920398.png)

**不能mov r1 [r2]：内存不能直接mov**

### 立即寻址

指令中操作数就是**数据本**身，即数据包含在指令中

取出指令也就取出了可以立即使用的数(称为立即数)

![image-20230505212958272](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505212958272.png)

### 寄存器偏移寻址

指令中操作数在使用前，首先执行**移位操作**

![image-20230505213200616](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505213200616.png)

### 移位操作

![image-20230505213236774](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505213236774.png)

### 寄存器间接寻址

指令操作数给出的是**通用寄存器的编号**

真正的数据保存在寄存器指定地址的存储单元中

即**寄存器为操作数的地址指针**

![image-20230505213454586](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505213454586.png)

### 基址寻址

将**基址寄存器的内容与指令中给出的偏移量相加**，形成操作数的有效地址

![image-20230505213525861](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505213525861.png)![image-20230505213647576](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505213647576.png)

### 多寄存器寻址

批量Load/Store指令用于实现在一组寄存器和一块连续的内存单元之间传输数据。

一次可传送几个寄存器值。允许一条指令传送不超过16个寄存器

![image-20230505213759358](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505213759358.png)

![image-20230505213819442](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505213819442.png)

**注意：**

感叹号！：寄存器本身要变化，**自身更新（如+4）**

#### 格式:

LDM|STM{<Cond>} <addressing_mode> <Rn>{!},<registers>{^}

 其中<addressing_mode> 可以有四种寻址方式:

1.**IA**(Increment After，事后递增方式)

2.IB(Increment Before，事先递增方式)

3.DA(Decrement After，事后递减方式)

4.DB(Decrement Before，事先递减方式)





### 堆栈寻址（*）

堆栈是存储器中一个按特定顺序(先进后出 or 后进先出)进行存取的区域

#### 隐含的寻址：

- 使用专门的寄存器(**即堆栈指针SP)**指向一块存储区域。
- SP所指向的存储单元称为栈顶。

#### 分类：

- **按入栈时SP的变化：**
  - 向上生长：向高（大）地址方向
    - 递增堆栈
  - 向下生长：向低（小）地址方向
    - 递减堆栈
  - ![image-20230505214052298](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505214052298.png)
- **按SP指向的内容：**
  - 满堆栈：SP指向**最后压入堆栈的有效数据项**
  - 空堆栈：SP指向**下一个待压入数据的空位置**
  - ![image-20230505214226948](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505214226948.png)
- 总结：
  - ![image-20230505214250897](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505214250897.png)

#### 例：

![image-20230505214501243](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505214501243.png)

- 入栈时：满递减
- 出栈时：满递增
- 高地址对应是寄存器的高地址
  - 编号大的地址高
  - 编号小的地址小


#### 关于LDMFD和STMFD

LDMFD博客：https://www.cnblogs.com/zuji0203/p/3601194.html

LD指令详解：https://www.cnblogs.com/getyoulove/p/3674168.html

在STM、LDM指令中，寄存器列表与内存单元的对应关系：

- **编号低**的寄存器对应于内存中**低地址**单元
- **编号高**的寄存器对应于内存中**高地址**单元

在ARM中常用的数据进栈与出栈方式分别为**STMFD**和**LDMFD**。

**STMFD**——ST表示Store；M表示Multiple;F表示Full；D表示Descend。

**LDMFD**——LD表示Load；M表示Multiple;F表示Full；D表示Descend。

##### 地址计算方法：

- STMFD：**事前递减方式(DB)**

  - (由于在FD增长方式下SP指针指向满栈顶，需要先求址再入栈)
  - 假设当前SP指向的地址为adress；

  - **STMFD SP! {R0-R7,LR}** ;
    - adress-4<——[LR];
    - adress-4*2<——[R7];
    - *...........;*
    - adress-4*9<——[R0].

  - {！}表示将数据全部压入堆栈中时，SP指向最后的地址。

- LDMFD：**事后递增方式(IA)**

  - (由于在FD增长方式下SP指针指向满栈顶，先出栈，SP指针再指向新的栈顶)
  - 假设当前SP指向的地址为adress；

  - **LDMFD SP! {R0-R7,LR}** ;
    - R0<——[adress];
    - R1<——[adress+4];
    - ...........,
    - LR<——[adress+4*9].

  - {！}表示将数据全部出栈时，SP指向最后的地址

- 注意：

  - 数据出栈时，**LDMFD中的FD只是说明为堆栈的生成方向**，其与之前的STMFD相对应
  - **并不是指SP指向的地址是从高到低的。**
  - 堆栈是先进后出的，进栈顺序决定了出栈顺序！



![image-20230514233823109](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230514233823109.png)

![image-20230514233907588](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230514233907588.png)

作用：从堆栈中加载之前保存的寄存器的值，并恢复到之前的状态



### 相对寻址

基址寻址的一种变通

由**程序计数器PC提供基准地址**，**指令中的操作数作为偏移量**，两者相加得到的地址即为有效地址EA

![image-20230505214935712](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505214935712.png)

## 指令集

### 分类

- **RISC→加载/存储(Load/Store)型：**

  - 指令集仅能处理**寄存器**中的数据，而且处理结果要放回寄存器。

  - 对**存储器的访问需要通过专门的加载/存储指令**来完成。

- 带T变种的微处理器（如ARM7TDMI-S等）的指令集，包括：

  - ARM指令集
    - 高效
    - 快速

  - Thumb指令集
    - 灵活
    - 小巧
  - ![image-20230505215117479](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505215117479.png)

### 基本格式

![image-20230505215230676](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505215230676.png)

其中：<>号内的项是必须的，{}号内的项是可选的

##### cond

- 可以实现高效的逻辑操作，提高代码效率。
- **所有的ARM指令都可以条件执行**
- 而**Thumb指令只有B（跳转）指令具有条件执行**功能。
- 如果不标明条件码，则默认为**无条件**(AL)执行

![image-20230505215350255](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505215350255.png)

##### 标志影响位S

默认情况下，**数据处理指令不影响CPSR的条件标志位**(N、Z、C、V)

但可以选择通过**添加“S”来影响**

**注意：**

- **比较指令不需要添加“S”**，默认改变条件标志位

**例：**

- 

![image-20230505215439807](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505215439807.png)

![image-20230505215550894](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505215550894.png)



### 分支指令

- 用于实现程序流程的跳转。
- 在ARM程序中有两种方法可以实现程序的跳转：
  - 使用专门的**跳转指令**。——可以实现在**向前或向后32MB**地址空间的跳转
  - 直接向**程序计数器PC写入跳转地址值**。——可以实现在**4GB**地址空间的跳转
- 在跳转之前结合使用指令**MOV LR，PC，可以保存返回**
  **的地址值**，从而实现在4GB地址空间的子程序调用

![image-20230505215732752](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505215732752.png)

**注意：**

- **如果直接向pc写跳转地址值，低两位不能是除00以外的数**
  - ARM指令是**32位**的，指令地址都是**4字节对齐**，所以**PC值肯定是4的倍数**，**最低两位总是为0**。
  - 如果低两位不为0，就会导致跳转到一个**非法的指令地址**，造成错误

### 数据处理指令

![image-20230505215922720](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505215922720.png)

- 只能对**寄存器**进行操作，不能对存储器进行操作。
- 可**选择使用S后缀，并影响状态标志**
  - **比较指令**即使不使用S后缀，也会影响状态标志

#### 数据传送

![image-20230505220029687](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505220029687.png)

- 数据非传送
  - 把**操作数每一位取反**再传送

#### 比较指令

![image-20230505220036106](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505220036106.png)

#### 算术运算指令

![image-20230505220050601](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505220050601.png)

#### 逻辑运算指令

![image-20230505220110871](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505220110871.png)

#### 乘法指令

![image-20230505220435413](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505220435413.png)

![image-20230505220441544](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505220441544.png)



### 存储器访问指令

![image-20230505220842375](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505220842375.png)

- 用于对内存变量的访问、内存缓冲区数据的访问、查表、外围部件的控制操作等。
- 使用**单寄存器加载指令加载数据到PC寄存器**，实现程序的**跳转**功能

#### 单寄存器加载、存储

![image-20230505220941179](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505220941179.png)

![image-20230505221103972](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505221103972.png)

##### 字和无符号字节

S：有符号

B：字节

**STR**指令：用于将寄存器中的**一个字或字节**数据保存到内存

- STR Rd,<地址> ;存入一个字（32位）
- STR**B** Rd,<地址> ;存入一个字节，高24位不变

**LDR**指令：用于从内存中读取**一个字或字节**数据，存入寄存器中

- LDR Rd,<地址> ;读出一个字（32位）
- LDR**B** Rd,<地址> ;读出一个字节，高24位补0

##### 半字和有符号字节

**LDR**指令：

- LDR**SB** Rd,<地址> ;读出一个带符号字节，高24位补齐符号位
- LDR**SH** Rd,<地址> ;读出一个带符号半字，高16位补齐符号位
- LDR**H** Rd,<地址> ;读出一个无符号半字，高16位补0

STR指令：

- STR**H** Rd,<地址> ;写入半字，高16位不变



##### 例1：

![image-20230505222430123](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505222430123.png)

##### load/store指令应用举例——链表搜索操作

- 每个链表元素包括两个字：
  - **第1个字中包含一个字节数据；**
  - 第2个字中包含**指向下一个链表元素的指针**
    - 为0时表示链表结束
  - ![image-20230505222617414](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505222617414.png)
- 执行前**R0指向链表的头元素**，**R1中存放要搜索的数据**
- 执行后**R0指向第1个匹配元素**；若没有匹配元素，R0为0

![image-20230505222738335](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505222738335.png)

#### 多寄存器加载、存储

实现在一组寄存器和一块连续的内存单元之间传输数据。

- LDM：加载多个连续的内存单元内容到多个寄存器。
- STM：存储多个寄存器内容到多个连续的内存单元

![image-20230505223053122](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505223053122.png)

##### 指令格式

- 寄存器**Rn为基址寄存器**：用于存放传送数据的初始地址，
  - Rn不允许为R15（即PC）。
- 后缀“!”：表示最后的地址要写回Rn。**——更新Rn**
- 寄存器列表reglist：可包含多个寄存器或寄存器范围，
  - 使用“，”分开，例如{R1，R2，R6-R9}。
  - ARM规定：寄存器按由小到大排列（★）。
- 后缀“^”：不允许在用户模式或系统模式下使用。
  -  LDM指令：**若寄存器列表中包含PC，除正常的多寄存器传送外，还将SPSR拷贝到CPSR，用于异常处理返回。**
  - 若寄存器列表不包含PC，则加载/存储的是用户模式的寄存器，而不是当前(异常)模式的寄存器

##### 模式

![image-20230505223309826](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505223309826.png)

##### 例：

![image-20230505223329814](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505223329814.png)

#### **寄存器与存储器交换指令**

SWP指令：用于将一个**内存单元(地址在寄存器Rn中)**的内容读取到一个**寄存器Rd**中，同时将另一个**寄存器Rm**的内容写入到该内存单元中

![image-20230505223611614](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505223611614.png)

例：

![image-20230505223718597](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505223718597.png)

### 杂项指令

![image-20230505223829787](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505223829787.png)

#### 读写状态

![image-20230505223904287](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505223904287.png)

##### 状态寄存器格式：

![image-20230505224013594](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505224013594.png)

##### 配合使用例：

![image-20230505223947832](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505223947832.png)

#### 软中断

SWI指令：用于产生**异常中断，实现用户模式到管理模式的切换**，从而在用户模式下能够调用操作系统中特权模式的程序

执行流程：将处理器置于svc(管理)模式，并**将CPSR保存到SPSR_svc中**，然后跳转到SWI异常处理程序入口(异常向量地址为0x00000008)

![image-20230505224225747](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505224225747.png)

##### SWI

用途：主要用于用户程序调用操作系统的API

参数传递方法：

- 指令中的**24bit立即数指定API号**，其它参数通过寄存器传递
  - ![image-20230505224538172](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505224538172.png)
  - ![image-20230505224639568](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505224639568.png)
- **忽略指令中的24bit立即数，由R0指定API号**，其它参数通过其它寄存器传递
  - R0——API号
  - R1、R2——传参数
  - 0——立即数取任何值都可以
  - ![image-20230505230450183](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505230450183.png)
  - ![image-20230505230235802](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230505230235802.png)

## ARM汇编程序设计

### 例1：实现乘法指令

![image-20230506100752951](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506100752951.png)

### 例2:64位数据运算

设R0和R1存放一个64位数，**R0存放低32位**

R2和R3中存放另一个64位数，**R2存放低32位**

- 加法，结果在R0和R1中：
  - ![image-20230506100934330](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506100934330.png)
- 减法，结果在R0和R1中：
  - ![image-20230506100956475](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506100956475.png)
- 比较：
  - ![image-20230506101017931](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506101017931.png)

### 例3：转换内存中数据存储方式

将寄存器R0中的数据存储方式转换成另一种存储方式。

指令执行前R0数据存储方式为：**R0=A,B,C,D**；

指令执行后R0数据存储方式为：**R0=D,C,B,A**

![image-20230506101157489](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506101157489.png)

- 第一步：
  - 先使用逻辑异或操作（EOR）对寄存器R0进行旋转右移16位（ROR #16）
  - 然后与R0进行异或运算，结果存储在R1中。
  - 根据注释，可以得出R1的结果是A与C的异或、B与D的异或、C与A的异或以及D与B的异或。
- 第二步：
  - 使用位清除操作（BIC）将R1与掩码#0xFF0000进行按位与运算，清除了R1中的高8位（0xFF0000）。
  - 根据注释，可以看到此操作将R1的第2个和第3个元素设置为0，即变成了A与C的异或、0、C与A的异或以及D与B的异或。
- 第三步：
  - 将寄存器R0进行旋转右移8位（ROR #8），然后将结果移动到R0中。
  - 根据注释，可以看到此操作将R0的元素重新排列成D、A、B、C的顺序
- 第四步：
  - 使用逻辑异或操作（EOR）对寄存器R0和寄存器R1进行逻辑右移8位（LSR #8）后的结果进行异或运算，然后将结果存储在R0中。
  - 根据注释，可以看到此操作将R0的元素重新排列成D、C、B、A的顺序

### 例4：子程序的调用

![image-20230506101309132](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506101309132.png)

### 例5：条件执行

![image-20230506101340155](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506101340155.png)

### 例6：循环语句

![image-20230506101408931](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506101408931.png)







## Thumb指令集

### **Thumb指令**

- 可以看作是ARM指令压缩形式的子集
  - 为减小代码量而提出
  - 具有16位的代码密度。
- 指令体系不完整，只支持通用功能。
- 必要时仍需要使用ARM指令
  - 例如：进入异常时。

### 与ARM区别

- 只有**B指令可以条件执行**，其它都不能条件执行。
- 分支指令的**跳转范围有更多限制**。
- **单寄存器访问指令(LDR/STR)只能操作R0～R7。**
- 多寄存器访问指令(LDM/STM)可对R0～R7的任何子集进行操作。
- PUSH和POP指令：R0~R7，PC















# 嵌入式程序设计基础

## 伪指令

有一些特殊指令助记符，与指令系统的助记符不同，**没有相对应的操作码**，他们所完成的操作称为伪操作

作用：**既要把正常的程序用指令表达给计算机以外，又要把程序设计者的意图表达给编译器**

例：例如：要告诉编译器程序段的开始和结束，需要定义数据等。

- 通用伪指令
- 与ARM指令相关的伪指令
- 与Thumb指令相关的伪指令

### 通用伪指令

- 符号定义伪指令
- 数据定义伪指令
- 汇编控制伪指令
- 其他一些常用伪指令等

#### 符号定义

**声明ARM汇编程序中的变量、对变量赋值以及定义寄存器的名称等操作**

##### 全局变量

**GBLA、GBLL和GBLS**

![image-20230506102745358](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506102745358.png)

例：

- 指令示例：
- GBLA DATE1；声明一个全局数字变量DATE1
- GBLL DATE2；声明一个全局逻辑变量DATE2
- GBLS DATA3；声明一个全局的字符串变量DATE3
  - DATE3 SETS“Testing”；将该变量赋值为“Testing

##### 局部变量

**LCLA、LCLL和LCLS**

![image-20230506102936681](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506102936681.png)

例：

- 指令示例：
- LCLA DATE4；声明一个局部数字变量DATE4
- LCLL DATE5；声明一个局部的逻辑变量DATE5
  - DATA4 SETL 0x10；为变量DATE4赋值为0x10
- LCLS DATA6；声明一个局部的字符串变量DATA6

##### 变量赋值

**SETA、SETL和SETS**

![image-20230506103050067](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506103050067.png)

![image-20230506103217656](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506103217656.png)

##### 寄存列表

![image-20230506103239976](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506103239976.png)

#### 数据定义

##### 字节分配内存：DCB

![image-20230506103329488](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506103329488.png)

##### 半字分配内存单元：DCW

![image-20230506103405890](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506103405890.png)

##### 字分配内存单元：DCD

![image-20230506103432844](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506103432844.png)

##### 浮点数：DCFD

![image-20230506103513310](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506103513310.png)

例：

![image-20230506103530685](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506103530685.png)

##### 双字分配内存单元：DCQ

![image-20230506103558368](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506103558368.png)

##### 内存表定义：MAP、FILED

![image-20230506103635719](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506103635719.png)

![image-20230506103656434](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506103656434.png)

**注意：**

- **只定义数据结构，不实际分配存储单元**
- FIELD +MAP **配合使用来定义结构化的内存表**。
  - MAP 伪指令：
    - 定义内存表的**首地址**，
  - FIELD 伪指令“
    - 定义**内存表中的各个数据域**，并可以为每个数据域指定一个标号供其他的指令引用

![image-20230506103834521](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506103834521.png)

##### 内存单元分配：SAPCE

![image-20230506103947416](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506103947416.png)

#### 汇编控制

未完待续……





















# 嵌入式存储器系统

## 存储器类型

### 用途

- 主存储器：用来存放正在执行的或经常使用的程序代码和数据。
  - 通常由半导体存储器构成。位于**微处理器芯片内部**或者主板上。
  - **存取速度快**，CPU可以直接对主存进行访问。
  - **容量有限**，其大小受地址总线位数的限制。
- 外部存储器：存放暂时不用的代码数据
  - **速度慢，微处理器不能直接访问**，仅在需要时被调入主存储器
  - **容量大，成本低**，所存储信息可长期保存，且能修改

### 存储介质

![image-20230506104514373](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506104514373.png)

### 存取方式

![image-20230506104537461](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506104537461.png)

#### RAM

- 静态随机存取存储器**SRAM**（Static RAM）
  - 一个bit存储单元由多个晶体管耦合（双稳态触发器）而成。
  - 存储内容可以**长时间保持**，除非掉电或执行写操作。
  - **速度非常快，但集成度低，结构复杂，功耗大**。

- 动态随机存取存储器**DRAM**（Dynamic RAM）
  - 一个bit存储单元由一个场效应管及其栅极对地接一个电容组成。
  - 存储内容一定时间后会**自动消失**，需要周期性刷新——**（充电）**。
  - 速度比SRAM慢一些，但集成度高，成本低，功耗低。
- 同步动态随机存取存储器**SDRAM**（Synchronous DRAM）
  - 将CPU和RAM共享一个时钟周期，两者以相同的速度同步工作，**在每一个时钟脉冲的上升沿开始传输数据**。
- 双倍数据速率动态随机存取存储器**DDR SDRAM**（Double Data Rate SDRAM）
  - **允许在时钟脉冲的上升沿和下降沿两次传输数据**，从而在不提高时钟频率的情况下能加倍提高SDRAM的传输速度。

#### ROM

![image-20230506104849928](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506104849928.png)

#### 闪存

闪速存储器Flash Memory——**非易失性存储器，可读可写**

- **Nor Flash** 
  - 并行连接的存储单元阵列。
    - 存储单元以字节（Byte）为单位进行操作，可以直接访问每个存储单元
  - 具有**芯片内执行**（eXecute In Place）特性。应用程序可以**直接在其内运行，不必先读到RAM中再运行**
  - 数据传输效率很高，使用方便在小容量时具有很高的成本效益。
  - **写入和擦除速度很低，大大影响其性能**。
- **NAND Flash**
  - 并行连接的存储单元阵列。
    - 存储单元按页（Page）进行操作，
    - 以块（Block）为单位进行擦除
  - 能提供极高的单元密度，可以达到**高存储密度，并且写入和擦除的速度也很快。**
  - 存储器管理较为复杂、系统接口特殊



##### 对比：

![image-20230506105057570](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506105057570.png)

nand flash io只有8根数据线，通过**时序**分别输出控制、数据信息



## 存储器结构

![image-20230506105522729](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506105522729.png)

![image-20230506105533452](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506105533452.png)

### 空间分布

以S3C2440为例：

- 

- 支持小端/大端模式
- 寻址外部存储空间1GB：
  - 分成**8个Bank(Bank0～Bank7)**，每个Bank为128MB。(8×128MB = 1024MB = 1GB)
  - Bank0：数据位宽只能是16或者32位(由引脚电平决定)，其它Bank可以编程设定为8、16或者32位
  - Bank0～Bank5：可以外接ROM、SRAM类型的存储器
  - Bank6 和 Bank7：
    - 可 以 外接 ROM 、 SRAM、SDRAM类型的存储器
    - Bank6和Bank7的大小可以编程设定。
  - 前7个Bank(Bank0～Bank6)有固定的起始地址；最后1个Bank(Bank7)起始地址 = Bank6的末地址 + 1。
  - 所有Bank的访问周期可编程设定。

#### BANK0

![image-20230506105938633](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506105938633.png)

#### BANK1-7

![image-20230506110017477](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506110017477.png)

#### 地址空间

![image-20230506111438128](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506111438128.png)

有32根地址线——4G

剩下3G给外围设备



![image-20230506111500159](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506111500159.png)

![image-20230506111522665](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506111522665.png)

#### NAND引导ROM启动

![image-20230506111601939](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506111601939.png)



## 存储器芯片连接

8位存储器芯片：低端领域使用。
16位存储器芯片：在成本和功耗上有显著优势。
32位存储器芯片：性能高，但价格昂贵，故使用很少

本质上是三种总线的连接：

- 数据
- 地址
- 控制

![image-20230506111715606](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506111715606.png)

### 数据线连接

将存储器芯片的数据引脚与微处理器芯片的数据引脚顺序连接

### 控制总线连接

将存储器芯片的控制引脚（读/写/片选等）与微处理器芯片对应的控制引脚连接

### 地址线连接

![image-20230506111827392](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506111827392.png)

- A0连接的是芯片的**低位地址**



### 存储器芯片连接实例（*）

- 8位存储器芯片构成8位存储器系统
  - ![image-20230506112624900](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506112624900.png)

- 两片8位存储器芯片**并联成16位**存储器系统

  - ![image-20230506112704205](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506112704205.png)
  - ![image-20230506112716254](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506112716254.png)
  - 数据线：
    - 按照**低位——高位连接**

  - 地址线：
    - 都连接到芯片地址总线
      - A1——A0
      - A2——A1
      - A3——A2

- 四片8位并联32位
  - ![image-20230506113512094](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506113512094.png)
    - ![image-20230506113523108](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506113523108.png)
    - ![image-20230506113537667](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506113537667.png)

- 16位芯片构成16位存储器系统
  - ![image-20230506113631218](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506113631218.png)
  - ![image-20230506113640625](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506113640625.png)

未完待续



## NOR FLASH芯片

### 特点：

- 读取速度快，具有芯片内执行XIP特性。
- 写入速度慢，单位体积下容量小，价格高。
- 擦写次数约10万次。
- 带有SRAM接口，与微处理器连接方便，便于数据存取。
- 适用于存储固化的系统启动引导代码、操作系统代码、应用程序代码。
- **通常配置到Bank0**。当系统上电或复位后从其内获取指令并开始执行

### 实例：

![image-20230506113804035](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506113804035.png)

![image-20230506113848125](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506113848125.png)





## NAND FLASH芯片

### 特点：

- 擦除和写入速度很快。单位体积下数据存储密度大，价格相对便宜。
- 使用时需要**复杂的I/O接口电路**（专用控制器）和存储管理操作。
  - 以页(Page)为最小单位进行读写；以块(Block）为最小单位进行擦除
  - nand flash io只有8根数据线，通过**时序**分别输出控制、数据信息
- 擦写次数约100万次。
- 用于存储大量的用户数据、程序代码。
- 支持自动启动引导

![image-20230506114151104](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506114151104.png)

![image-20230506114209487](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506114209487.png)

### 实例：K9F1208

- 有效容量**64MB**
  - 被分为4096块，每块32页，每页528字节
  - （前512字节用于存放有效数据，后16字节作为用于存放ECC代码、坏块信息和文件系统代码等辅助数据）
  - ![image-20230506114344958](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506114344958.png)
- **没有对外的地址线 ，但芯片内部使用地址线**
  - A25-A14-A9A8A7-A0表示其各字节单元地址
  - **A25~A14**是12根块地址线——**提供块索引**
  - **A13~A9**是5根页地址线——**提供页索引**
  - **A8~A0**是列地址线——**提供页内偏移**地址。
    - A8=0：选中1st Half Page（256字节）
    - A8=1：选中2nd HalfPage（256字节）。
    - A7～A0是选中的Half Page的页内偏移地址。

### 存储器读写过程

当从芯片中读取数据时：

- 读取页的时候**一次只能读半页**
- 分**两次把一个页**的数据读取完

过程：

- 读取1st Half Page使用命令0x00代替A8=0
- 读取2ndHalf Page使用命令0x01代替A8=1。

- 发 送 地 址 信 号 时 按 字 节 分 为 
  - A0~A7 
  -  A9~A16 
  - A17~A24
  - A25
  - 即采用**四步寻址法**。
    - 物理地址 = 块编号×块大小 + 页编号×页大小 + 页内偏移地址

![image-20230506114932316](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506114932316.png)

![image-20230506114944438](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506114944438.png)

### 微处理器引脚

- **NCON: 存储器选择位**
  - ✓当NCON=0时，选择普通NAND Flash（256字/512字节页大小，3/4地址周期）。
  - ✓当NCON=1时，选择高级NAND Flash（1K字/2K字节页大小，4/5地址周期）。
- **GPG13: 存储器页容量选择位**
  - ✓当GPG13=0时，页=256字(NCON=0)或页=1K字(NCON=1)。
  - ✓当GPG13=1时，页=512字节(NCON=0)或页=2K字节(NCON=1)
- **GPG14: 存储器地址周期选择位**
  - ✓当GPG14=0时，3个地址周期(NCON=0)或4个地址周期(NCON=1)。
  - ✓当GPG14=1时，4个地址周期(NCON=0)或5个地址周期(NCON=1)。
- **GPG15 存储器总线宽度选择位**
  - ✓当GPG15=0时，8 位总线宽度
  - ✓当GPG15=1时，16位总线宽度

![image-20230506115217759](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506115217759.png)

### 工作模式

- **自动引导模式**
  - S3C2440 的引脚OM1 、 OM0 均接为低电平时，则系统处于NAND Flash自动引导模式
- **普通闪存模式**
  - 支持数据读、写、擦除操作

![image-20230506115353789](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230506115353789.png)



## 存储器控制寄存器





# 常用外围设备及接口

## 通用输入输出端口

**GPIO**(General Purpose I/O)——通用输入输出端口，是嵌入式系统的重要组成部分

- 用于连接各种类型的输入输出设备，以实现它们与微处
  理器之间的数据传输
- GPIO在**芯片内部**

![image-20230510101313063](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510101313063.png)

### 构成

![image-20230510101354361](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510101354361.png)

- 端口GP没有I

#### 端口A

- 23个引脚。
- 两种功能：
  - 普通**输出**口；
  - 用于输出外接存储器的**地址信号和存储块的选择**信号
  - ![image-20230510102027529](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510102027529.png)

#### 端口B

- 11个引脚。
- 两种功能：
  - 普通**输入/输出**口；
  - 用于DMA和总线请求信号和应答信号以及各种时钟信号
  - ![image-20230510102037727](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510102037727.png)

#### 端口C

- 16个引脚。
- 两种功能：
  - 普通**输入/输出**口；
  - 用于**LCD显示器**的数据信号和控制信号。

#### 端口D

- 16个引脚。
- 三种功能：
  - 普通**输入/输出**口；
  - 用于**LCD显示器的数据**信号。
  - 用于**SPI总线的控制**信号。

#### 端口E

- 16个引脚。
- 三种功能：
  - 普通**输入/输出**口；
  - 用于SPI、I2C、I2S总线和SD存储器的控制信号。
  - 用于AC’97音频接口的控制信号

#### 端口F

- 8个引脚。
- 两种功能：
  - 普通**输入/输出**口；
  - 用于**中断请求信号——常用**

#### 端口G

- 16个引脚。
- 三种功能：
  - 普通**输入/输出**口；
  - 用于**中断请求信号**。
  - 用于SPI总线、LCD显示器的控制信号。

#### 端口H

- 11个引脚。
- 三种功能：
  - 普通**输入/输出**口；
  - 用于异步串行接口UART的控制信号；
  - 用于异步串行接口UART的控制信号（仅两个）
- ![image-20230510102501168](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510102501168.png)
  - RXD:接收
  - TXD:传输

#### 端口J

- 13个引脚。
- 两种功能：
  - 普通**输入/输出**口；
  - 用于摄像头接口的数据信号和控制信号



### IO端口的使用

- 通过端口的**控制寄存器**来设定
  - 每个IO的引脚使用哪些功能
  - IO端口的状态
  - ![image-20230510102715955](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510102715955.png)



#### 上拉寄存器

上拉寄存器是一种**控制端口上拉电阻**的寄存器，可以控制每组端口的**上拉电阻为禁止还是使能**。

作用：

- 提高**输入**端口的**电平稳定性**
- 避免输入端口因为没有外部信号而漂移，从而**保证输入端口的状态正确。**



#### 端口A

##### 控制寄存器

![image-20230510102946631](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510102946631.png)

##### 注意：

- ARM中寄存器：

  - 为**微处理使用的**：
    - **同汇编，在内存中分配**

  - 为**外围设备**使用的：
    - 特殊功能寄存器FSR（**有地址**）

##### 数据寄存器

![image-20230510103232258](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510103232258.png)

##### 配置寄存器

![image-20230510103300848](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510103300848.png)

![image-20230510103308910](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510103308910.png)

#### 端口B

##### 控制寄存器

![image-20230510103335548](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510103335548.png)

##### 数据寄存器

![image-20230510103349071](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510103349071.png)

##### 配置寄存器

![image-20230510103408711](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510103408711.png)

##### 上拉寄存器

![image-20230510103423390](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510103423390.png)



#### 端口C-J

详见《S3C2440用户手册》



#### 例：GPIO连接LED灯

![image-20230510103544966](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510103544966.png)

##### 端口F寄存器

![image-20230510103833864](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510103833864.png)

##### 注意：输入输出分析

- 输入输出分析要注意主体：
  - **以微处理器为主体（√）**
    - **芯片输出信号**
    - **LED灯被输入信号**
  - 以LED灯为主体（×）
    - LED灯输出
    - 芯片输入

所以在本例中，**GPF4-6是输出端，应该选01（output）**



##### 汇编代码分析

![image-20230510103957210](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510103957210.png)

- LDR R0,=0x56000050
  - **=号是LDR伪指令**  ≈  **MOV**
  - 将GPIO端口F的**配置寄存器**地址加载到寄存器R0中
- LDR R1,[R0]
- BIC R1,R1,#0x3F00
  - BIC：位清零
  - 将R1和 **#0x3F00的反码**进行**与运算**，存到R1中
  - #0x3F00：
    - ![image-20230510105025455](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510105025455.png)
  - 取反之后：
    - **11    11  11  11  11**
  - **GPF4-6为0，与运算后为0**
  - 所以**GPF4-6清零**
- ORR R1,R1,#0x1500
  - ORR：位或
  - 将R1和**#0x1500进行或运算**，存到R1中
  - #0x1500：
    - ![image-20230510105603035](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510105603035.png)
  - 因为R1的GPF4-6是：
  - **00  00  00**
  - 或运算完结果：
  - GPF4-6设为 **01  01  01**
- STR R1,[R0]
  - 将寄存器R1中的数据写入到地址R0所指向的寄存器中，完成GPIO端口F的配置寄存器
- LDR R0,=0x56000054
  - 将GPIO端口F的数据寄存器地址加载到寄存器R0中
- LDR R1,[R0]
- BIC R1,R1,#0x70：
  - #0x70：
    - ![image-20230510110010192](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510110010192.png)
  - 取反：
    - **1  0  0  0  1  1  1  1**
  - 位清零，将R1寄存器中的**GPF4～GPF6位清零**，将它们的**输出设置为低电平**
- STR R1,[R0]：
  - 将寄存器R1中的数据写入到地址R0所指向的寄存器中，将GPIO端口F的输出设置为低电平



## 中断系统

### 概念

![image-20230510111441326](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510111441326.png)

### 作用

![image-20230510111647324](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510111647324.png)

### 构成

ARM920T微处理器(内核)的7种异常模式中：

- 芯片**外部中断**请求引脚：
  - 外部中断请求(IRQ)
- 内部外设触发：
  - 快速中断请求(FIQ

借助**中断控制器**，接收并管理60个中断源发出的中断请求信号

![image-20230510112508357](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230510112508357.png)





- 一级中断源：

  - 表面32个，实际45个

- 二级中断源：借助一级中断源

  - 15个

- 外部中断源：

  - 0-3作为一级中断源，4-7，8-23二级中断源

  

- SFR：

  - 一级：


  - 二级：SUB


  - 外部：E



#### 一级中断源

直接送入内核进行处理

- 表面32个，实际45个
  - INT_LCD有两个中断
  - EINT8_23
  - EINT4_7

#### 一级中断源的SFR

![image-20230517102753205](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230517102753205.png)

##### 源挂起寄存器

- 用于**标记**32个一级中断源的中断请求信号是否触发
- 每一位有中断源自动置位
  - **不受优先级逻辑的影响**
- 在中断服务程序中**人工清除置位**
  - 写入数据1：清除
  - 写入数据0：保持不变

![image-20230517102936824](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230517102936824.png)

##### 中断模式寄存器

- 设定一级中断源的中断模式
  - **1：FIQ**模式处理
  - **0：IRQ**模式处理

- 同一时刻**只有一个中断源能在FIQ模式下**处理
  - 要把**最紧迫的中断**源设置为FIQ模式

![image-20230517103200026](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230517103200026.png)



##### 中断屏蔽寄存器

- 设定一级中断源是否允许被中断
  - 1：不会被服务
  - 0：可以被服务

![image-20230517103246782](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230517103246782.png)

##### 中断优先级

- 中断请求信号同时有效时，通过优先级确定服务顺序
- 中断控制器借助**优先级裁决器（仲裁判决器）**进行优先级判决

![image-20230517103447583](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230517103447583.png)

![image-20230517103510141](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230517103510141.png)

**芯片   <---   二级   <---   一级**

裁决时都是IRQ模式，不是FIQ（因为FIQ就一个，没有优先级一说）



###### 优先级类型：

- **静态优先级——固定**
  - REQ1~REQ4优先级设定好，就固定不再变化
- **动态优先级——循环**
  - REQ1~REQ4优先级设定好，**被中断处理之后，优先级自动被降为最低**

###### 优先级寄存器

- 设定中断源在IRQ模式下的优先级顺序
- 优先级通过2位ARB_SEL（顺序）和 1位ARB_MODE（优先级类型）设定

![image-20230517104234434](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230517104234434.png)

![image-20230517104300260](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230517104300260.png)

![image-20230517104310351](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230517104310351.png)

##### 中断挂起寄存器

- **标记**中断源的中断请求是否即将或者正在被微处理器服务
  - 0：未请求
  - 1：中断源在**所有已触发的中断优先级最高**且没有被屏蔽
- 位于优先级逻辑之后，同一时刻，只有1位被置1
  - 仅对IRQ模式的中断有效
- 需要在**中断服务程序中人工清除置位**
  - 向标志寄存器中写入1：清除
  - 0：保持不变

![image-20230517104533483](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230517104533483.png)

##### 中断偏移寄存器

- 标记INTPND中置1位对应中断源的偏移量，代表中断源号
- 一旦人工清除了SRCPND和INTPND中的置1位，该寄存器中的值会自动清除
  - 仅对IRQ模式有效

![image-20230517104748527](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230517104748527.png)





#### 外部中断源的SFR

![image-20230517105049203](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230517105049203.png)

注意：

- 对于每个寄存器的分析：横过来看，对每一位进行判断



##### 外部中断控制寄存器

- 设定外部中断请求信号的触发方式
  - **电平触发：低电平触发，高电平触发**
  - **边沿触发：下降沿触发、上升沿触发、双边沿触发**





注意：

4n+2:4n：每三位进行信号的触发设置





##### 外部中断滤波寄存器

- 设定8个外部中断请求信号（EINT16-EINT23）滤波器的时钟信号的时钟来源和滤波宽度

- 为了保证微处理器有效检测外部中断信号——**信号电平保持40ns**





##### 外部中断屏蔽寄存器：

- **设定**20个**外部中断请求信号（EINT4-EINT23）**是否允许中断



注意：

- **注意初始值**
  - 初始化的时候，**根据功能决定是否屏蔽初始值**
- **EINT0-EINT3被寄存器保留，不进行设置的原因：**
  - 0-3在一级中断源的中断屏蔽寄存器中已经设定了
  - ![image-20230518173158673](https://techla-img.oss-cn-hangzhou.aliyuncs.com/CODE/WEB/image-20230518173158673.png)

##### 外部中断挂起寄存器

- 用于**标记**20个外部外部中断请求信号是否触发





#### 中断处理流程

- 过程：
  - 请求源请求
  - EINTPEND：中断挂起：判断中断信号**是否触发**
  - EINTMASK：中断屏蔽：判断中断信号**是否允许被触发**
  - 

一定要经过mask屏蔽





#### 中断处理例：

开关通过中断方式点亮发光二极管



