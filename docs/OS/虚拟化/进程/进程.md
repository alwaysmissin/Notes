- [[#进程|进程]]
	- [[#进程#逻辑控制流|逻辑控制流]]
	- [[#进程#并发流|并发流]]
	- [[#进程#私有地址空间|私有地址空间]]
	- [[#进程#用户模式和内核模式|用户模式和内核模式]]
	- [[#进程#上下文切换|上下文切换]]
- [[#系统调用错误|系统调用错误]]
- [[#进程控制|进程控制]]
	- [[#进程控制#获取进程ID|获取进程ID]]
	- [[#进程控制#创建和终止进程|创建和终止进程]]
	- [[#进程控制#回收子进程|回收子进程]]
	- [[#进程控制#等待集合的成员|等待集合的成员]]
	- [[#进程控制#修改默认行为|修改默认行为]]
	- [[#进程控制#检查已回收子进程的退出状态|检查已回收子进程的退出状态]]
	- [[#进程控制#错误条件|错误条件]]
	- [[#进程控制#`wait`函数|`wait`函数]]
	- [[#进程控制#让进程休眠|让进程休眠]]
	- [[#进程控制#加载并运行程序|加载并运行程序]]
	- [[#进程控制#利用`fork`和`execve`运行程序|利用`fork`和`execve`运行程序]]
- [[#参考书目|参考书目]]

# 进程
## 进程
- 进程的经典定义: 一个执行中程序的实例
- 上下文: 系统中的每个程序都运行在某个进程的上下文中, 上下文是**由程序正确运行所需的状态组成的**
	- 包括存放在内存中的程序的代码和数据, 栈, 通用目的寄存器, 程序计数器, 环境变量, 打开文件描述符的集合
> [!note] 如何在shell中运行程序
> 每次用户通过向shell输入一个可执行目标文件的名字, 运行程序时, shell就会**创建一个新的进程**, 然后在这个新进程的上下文中运行这个可执行目标文件
> 应用程序也能够创建新进程, 并且在这个新进程的上下文中运行他们自己的代码或其他的应用程序

- **进程为应用程序提供的抽象**:
	- 一个独立的逻辑控制流 -> 程序独占使用资源
	- 一个私有的地址空间 -> 程序独占使用内存系统

### 逻辑控制流
- **程序计数器值的序列**即称为逻辑控制流
	- 程序控制器的值唯一的对应于包含在程序的可执行目标文件中的指令, 或是包含在运行时动态链接到程序的共享对象中的**指令**
![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231007164839.png)
- 进程是轮流使用处理器的, 每个进程执行它的流的一部分, 然后被**抢占**(preempted), 然后轮到其他进程

### 并发流
- 并发流: 一个逻辑流的执行在时间上与另一个流重叠
	- 这两个流称为并发的运行
- 并发: 多个刘并发的执行
- 多任务(multitasking): 一个进程和其他进程轮流运行
- 时间片(time slice): 一个进程执行它的控制流的一部分的每一时间段叫做时间片

### 私有地址空间
- 尽管和每个私有地址空间相关联的内存的内容一般是不同的, 但是每个这样的空间都**有相同的通用结构**
- 进程地址空间: ![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231007233737.png)
	- 地址空间的底部为**用户程序**使用, 包括代码, 数据, 堆和栈段
		- 栈是向下生长的
		- 堆是向上生长的
	- 地址空间的顶部保留给**内核**, 包含内核在代表进程执行指令时使用的代码, 数据和栈
- 在linux系统中查看某个进程的内存空间分布: `cat /proc/PID/maps`
```shell
$ cat /proc/17110/maps
5650f925b000-5650f925c000 r--p 00000000 08:20 269493                     /home/jiunian/Program/CSAPP/exception/snooze
5650f925c000-5650f925d000 r-xp 00001000 08:20 269493                     /home/jiunian/Program/CSAPP/exception/snooze
5650f925d000-5650f925e000 r--p 00002000 08:20 269493                     /home/jiunian/Program/CSAPP/exception/snooze
5650f925e000-5650f925f000 r--p 00002000 08:20 269493                     /home/jiunian/Program/CSAPP/exception/snooze
5650f925f000-5650f9260000 rw-p 00003000 08:20 269493                     /home/jiunian/Program/CSAPP/exception/snooze
7f6cec392000-7f6cec395000 rw-p 00000000 00:00 0
7f6cec395000-7f6cec3bd000 r--p 00000000 08:20 92881                      /usr/lib/x86_64-linux-gnu/libc.so.6
7f6cec3bd000-7f6cec552000 r-xp 00028000 08:20 92881                      /usr/lib/x86_64-linux-gnu/libc.so.6
7f6cec552000-7f6cec5aa000 r--p 001bd000 08:20 92881                      /usr/lib/x86_64-linux-gnu/libc.so.6
7f6cec5aa000-7f6cec5ae000 r--p 00214000 08:20 92881                      /usr/lib/x86_64-linux-gnu/libc.so.6
7f6cec5ae000-7f6cec5b0000 rw-p 00218000 08:20 92881                      /usr/lib/x86_64-linux-gnu/libc.so.6
7f6cec5b0000-7f6cec5bd000 rw-p 00000000 00:00 0
7f6cec5ca000-7f6cec5cc000 rw-p 00000000 00:00 0
7f6cec5cc000-7f6cec5ce000 r--p 00000000 08:20 92871                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f6cec5ce000-7f6cec5f8000 r-xp 00002000 08:20 92871                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f6cec5f8000-7f6cec603000 r--p 0002c000 08:20 92871                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f6cec604000-7f6cec606000 r--p 00037000 08:20 92871                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f6cec606000-7f6cec608000 rw-p 00039000 08:20 92871                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ffde1163000-7ffde1184000 rw-p 00000000 00:00 0                          [stack]
7ffde11e7000-7ffde11eb000 r--p 00000000 00:00 0                          [vvar]
7ffde11eb000-7ffde11ed000 r-xp 00000000 00:00 0                          [vdso]
```

### 用户模式和内核模式
- 处理器通过某个控制寄存器中的一个模式位来提供功能
- 当**设置了模式位**时, 进程就运行在**内核模式**
	- 内核模式中的进程可以执行指令集中的任何指令, 并且可以访问系统中的任何内存位置
- **没有设置模式位**时候, 进程就运行在**用户模式**
	- 用户模式中的进程不允许执行特权指令和直接引用地址空间中内核去内的代码和数据
		- 例如: 停止处理器, 改变模式位
- 运行应用程序代码的进程**初始时是在用户模式中**的
- 进程从用户模式进入内核模式的方式: 中断, 故障或系统调用
- `/proc`文件系统
	- 允许了用户模式进程访问内核数据结构的内容
	- 将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构
		- 利用这个机制, 我可以使用`/proc`文件系统找出一般的系统属性, 或某个特殊的进程使用的内存段
> [!note] `/sys`
> `/sys`文件系统输出关于系统总线和设备的额外的底层信息

### 上下文切换
- 上下文: 内核重新启动一个被抢占的进程所需要的状态
	- 由一些对象的值组成: 
		- 通用目的寄存器, 浮点寄存器, 程序计数器, 用户栈, 状态寄存器, 内核栈和各种内核数据结构(描述地址空间的页表, 包含有关当前进程信息的进程表, 以及包含进程已打开文件的信息的文件表)
- 调度: 在进程执行的某些时刻, 内核可以决定抢占当前进程, 并重新开始一个先前被抢占了的进程
> 	在内核调度了一个新的进程运行后, 他就抢占当前进程, 并且使用一种称为上下文切换的几只来将控制转移到新的进程
- 上下文切换:
	1. 保存当前进程的上下文
	2. 恢复某个先前被抢占的进程被保存的上下文
	3. 将控制传递给这个新回复的进程
> [!note] 中断与上下文切换
> 中断也可能引起上下文切换. 比如: 所有的系统都有某种产生周期性定时器中断的机制, 通常为每1ms或每10ms. 每次发生定时器中断时, 内核就能判定当前进程已经运行了足够长的时间, 并且切换到一个新的进程.

![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231008081554.png)
1. 首先进程A运行, 直到进程A发出系统调用`read`从磁盘中请求数据, 发生上下文切换, 开始进行进程B中的代码
2. 磁盘发出中断, 表示数据已经传送到了内存中
3. 内核判定进程B已经运行了足够的时间, 再一次发生上下文切换, 继续执行进程A中的代码
> [!note] 上下文切换的基本单位
> 在早起的操作系统中, 进程是操作系统调度的基本单位,.
> 但随着更加轻量级的运行时抽象----线程的提出, 调度和上下文切换的基本单位由进程变为了线程

## 系统调用错误
- 当Unix系统级函数遇到错误是, 他们通常会返回`-1`, 并且设置全局整数变量`errno`来表示出现了什么错误
```c
if((pid = fork()) < 0){
	fprintf(stderr, "fork error: %s\n", strerror(errno));
	exit(0);
}
```

## 进程控制
### 获取进程ID
```c
#include <sys/types.h>
#include <unistd.h>

// 返回调用者的PID
pid_t getpid(void);
// 返回调用者的父进程的PID
pid_t getppid(void);
```

### 创建和终止进程
```c
#include <stdlib.h>

void exit(int status);
```
- `exit`函数以`status`退出状态来终止进程
> [!note] 设置退出状态
> 另外一种设置退出状态的方法是从主程序中返回一个整数值
```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
```
- 父进程通过调用`fork`函数创建一个新的运行的子进程
	- ![[虚拟化#fork()系统调用]]
- 程序是如何转换为进程的?  -> [[虚拟化#进程创建 更多细节]]

### 回收子进程
> [!note] 
> 当一个进程由于某种原因终止时, 内核并不是立即去将其从系统中清除.
> 相反, 进程被保持在一种**已终止**的状态, 直到它被父进程回收
> 当父进程回收已终止的子进程时, 内核将子进程的退出状态传递给父进程, 然后抛弃已终止的进程

> [!note] 僵尸进程
> 一个终止了但未被回收的进程称为僵尸进程
> 及时僵尸进程没有运行, 他们依旧会消耗系统的内存资源

> [!note] init进程
> 如果一个父进程终止了, 内核会安排`init`进程称为它的孤儿进程的养父.
> init进程的PID为1, 是在系统启动时由内核创建的, 不会终止, 是所有进程的祖先.
> 如果父进程还未回收它的僵尸进程就终止了, 则内核会安排init进程去回收僵尸进程

- `waitpid`: 进程可以通过调用这个函数来等待它的子进程终止或停止
```c
#include <sys/types.h>
#include <sys/wait.h>

// 如果成功, 则会返回子进程的PID
// 如果WNOHANG, 则返回0
// 如果其他错误, 则返回-1
pid_t waitpid(pid_t pid, int *statusp, int options);
```
- 默认情况下(`options=0`), `waitpid`**挂起调用进程的执行**, 直到它的**等待集合**中的一个子进程终止

### 等待集合的成员
- 等待集合的成员是由参数pid来确定的:
	- `pid > 0`: 等待集合时一个单独的子进程
	- `pid = -1`: 等待集合时父进程的所有子进程组成的

### 修改默认行为
- 通过将`options`设置为常量`WNOHANG`, `WUNTRACED`和`WCONTINUED`的各种组合来修改默认行为
- `WNOHANG`: 如果等待集合中的任何子进程都还没有终止, 则立即返回
	- 用于在等待子进程终止的同时, 如果还想做些有用的工作
- `WUNTRACED`: 挂起调用进程的执行, 直到等待集合中的**一个进程**变成已终止或被停止
	- 用于检查已终止和被停止的子进程
- `WCONTINUED`: 挂起调用进程的执行, 知道等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到`SIGCONT`信号重新开始执行
- 信号的组合: 我们可以用`|`运算将这些选项组合起来
	- `WNOHANG | WUNTRACED`: 立即返回

### 检查已回收子进程的退出状态
- 如果`statusp`参数非空, 则`waitpid`会在`status`中放上关于导致返回的子进程的**状态信息**
- 子进程退出状态的检查:
	- `WIFEXITED(status)`: 子进程通过调用`exit`或者`return`正常终止
	- `WEXITSTATUS(status)`: 返回一个正常终止的子进程的退出状态
		- 只有`WIFEXITED(status)`返回真时, 才会定义这个状态
	- `WIFSIGNALED(status)`: 如果子进程是因为一个未被 捕获的信号终止的, 则返回真
	- `WTERMSIG(status)`: 返回导致 子进程终止的信号的编号(只有`WIFSIGNALED(status)`为真时)
	- `WIFSTPPED(status)`: 如果引起返回的子进程当前是停止的
	- `WSTOPGIS(status)`: 返回引起子进程停止的信号的编号(只有 `WIFSTPPED(status)`真时)
	- `WIFCONTINUED(status)`: 如果子进程收到SIGCONT信号重新启动, 则返回真

### 错误条件
- 如果调用进程没有子进程, 则`waitpid`返回`-1`, 并且设置`errno`为`ECHILD`
- 如果`waitpid`被信号中断, 则返回`-1`, 并且设置`errno`为`EINTR`

### `wait`函数
- `wait`是`waitpid`函数的简化版

### 让进程休眠
```c
#include <unistd.h>
// sleep for <secs> seconds
unsigned int sleep(unsigned int secs);
```
- `sleep`: 如果请求的时间量已经到了, 则sleep返回0, 否则返回还剩下的要休眠的秒数
	- 提前返回的情况是: `sleep`被一个信号中断而过早地返回
- `pause()`: 让调用函数休眠, 直到进程收到一个信号

### 加载并运行程序
```c
#include <unistd.h>
// if error, return -1
int execve(const char *filename, const char *argv[], const char *envp[])
```
- `execve`: 加载并运行可执行目标文件`filename`, 并且附带参数列表和环境变量
	- 环境变量使用`name=value`表示
	- 加载`filename`后, 将控制传递给新程序的主函数
- 执行`execve`时, 操作系统完成的操作:
	- 根据`pathname`指明的路径, **将可执行文件的数据段和代码段载入到当前进程的地址空间中**
	- **重新初始化堆和栈**
		- 操作系统进行地址空间随机化操作, 改变堆和栈的起始地址, 增强**进程的安全性**(见[[内存越界引用和缓冲区溢出#栈随机化]])
	- **将PC寄存器设置到可执行文件代码段定义的入口点**
- 与`fork`不同, 对`execve`的成功调用不会返回
![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231010125544.png)
- `main`开始执行时候的栈结构:![image.png](https://raw.githubusercontent.com/alwaysmissin/picgo/main/20231010130319.png)
	- 参数和环境变量字符串
	- `libc_start_main`
- 与环境变量相关的函数:
```c
#include <stdlib.h>
// return value of name
char *getenv(const char *name);
// return = success ? 1 : 0
int setenv(const char *name, const char *newvalue, int overwrite);
void unsetenv(const char *name);
```

> [!note] 程序与进程之间的区别
> 程序是一堆代码和数据; 程序可以作为目标文件存在于磁盘上, 或者作为段存在于地址空间中
> 进程是执行中的程序的一个具体的实例
> 程序总是运行在某个进程的上下文中
> `fork`函数在新的子进程中运行相同的程序, 新的子进程是父进程的一个复制品
> `execve`函数在当前进程的上下文中加载并运行一个新的程序. 这个操作会覆盖当前进程的地址空间, 并没有创建一个新的进程. 新的程序仍然有相同的PID, 并且继承了调用execve函数时已经打开的所有文件.

### 利用`fork`和`execve`运行程序
- shell的实现原理

## 参考书目
- CSAPP
- OSTEP
- 银杏书