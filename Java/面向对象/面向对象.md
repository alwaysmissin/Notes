t# 面向对象

## 一、构造器

## 二、修饰符

1. 四种访问权限
   1. default
   2. private
   3. public
   4. protected

|  修饰符   | 当前类 | 同一包内 | 子孙类（同一包） | 子孙类（不同包） | 其他包 |
| :-------: | :----: | :------: | :--------------: | :--------------: | :----: |
|  public   |   Y    |    Y     |        Y         |        Y         |   Y    |
| protected |   Y    |    Y     |        Y         |       Y/N        |   N    |
|  default  |   Y    |    Y     |        Y         |        N         |   N    |
|  private  |   Y    |    N     |        N         |        N         |   N    |



## 三、封装

1. 追求：高内聚，低耦合
   1. 高内聚：类的内部操作细节自己完成，不允许外部干涉
   2. 低耦合：仅暴露少量的方法给外部使用





## 四、继承

1. 子类是父类的继承

2. java中只有单继承，没有多继承

3. 类与类之间的关系

   1. 继承
   2. 依赖
   3. 组合
   4. 聚合

4. 子类继承父类用关键字`extends`来表示

   `public class Student extends Person`(标准声明类后加上`extends 父类`)

   ​	1. 子类继承父类的所有方法和属性

5. `object`类

   1. 所有类都默认直接或间接继承自`object`类

## 五、super

1. `this`调用当前对象的方法，`super`调用父类的同名public方法

2. 子类的构造器使用`super()`调用父类的**同类型构造器**，并且必须在第一个语句
3. `super`只能出现在子类的方法或构造方法中
4. 与`this`的区别
   1. 代表对象不同
      1. `this`：本身调用者
      2. `super`：代表父类的应用
   2. 前提
      1. `this`：无需继承
      2. `super`：只有继承时候可用
   3. 构造方法
      1. `this()`：本类的构造
      2. `super()`：父类的构造

## final关键词
1. final类
	1. 不能被继承
2. final方法
	1. 不允许子类重写final方法
3. 用于修饰常量(替代const的作用)

## 六、方法重写

1. 静态方法

   1. 父类的引用指向子类
   2. 方法的调用只与定义的数据类型有关

   ```java
   A a = new A();
   B b = new A();
   ```

   

2. 非静态方法

   1. **重写只与非静态方法有关**，并且需要有继承关系
   2. **私有方法不能被覆盖**
   3. 方法名必须相同
   4. 参数表必须相同
   5. 修饰符范围可以扩大
   6. 方法体可以不同
   7. 抛出的异常：范围可以被缩小但不能扩大

   ```java
   B b = new A();		//同名方法为非静态方法
   //调用同名方法时，使用的都是A类的方法
   ```

   7. 为什么需要重写：
      1. 父类的功能子类不一定需要或不一定满足
   8. 快捷方式：alt+insert : override
   
3. 不能被重写的方法

   1. `static`
   2. `final`
   3. `private`

## 七、多态

1. 即同一方法可以根据发送对象的不同而采用多种不同的行为方式
2. 一个对象的实际类型是确定的，但是可以指向对象的引用类型有很多（ 父类、有关系的类）`father s = new son();`
3. 多态存在的条件
   1. 有继承关系
   2. 子类重写父类方法
   3. 父类引用指向子类对象`father s = new son();`
4. 注：多态是方法的多态，属性没有多态
5. 作用：
   1. 动态编译
   2. 通过父类new子类

```java
//Student是person的子类

//Student能调用的方法都是自己或者继承父类的
Student s1 = new Student();
//Person父类型，可以指向子类，但是不能调用子类独有的方法
Person s2 = new Person();
//想要调用的话，可以使用强制类型转化
//将对象类型强制转化为目标类型
((Student)s2).eat();
```

## 八、Instanceof和类型转化

1. `X Instanceof Y`
   1. 存在父子关系才可以编译通过
   2. 用于测试左边对象是否是右边类的实例
2. 类型转化
   1. 高转低（父转子）需要强制转化
3. 意义
   1. 方便方法的调用，减少重复



## 九、static关键词
- 静态即**固定的位置**
- 静态存储的数据在**整个程序运行的过程**都可以访问

1. 非静态方法可以直接通过`类.方法`来调用静态方法
2. 静态方法只能调用一次但是在构造时最先调用
3. 静态方法只能访问静态对象
4. 不能用static来修饰构造方法

## 十、抽象类

1. `abstract`关键词
2. 抽象类的所有方法，继承了它的非抽象子类，都必须实现它的方法

>java中，类只能单继承，接口可以多继承

3. 不能new抽象类（**不能进行实例化**）
4. 抽象类可以写普通方法
5. 抽象方法必须在抽象类中

## 十一、接口

1. 区别
   1. 普通类：只有具体实现
   2. 抽象类：具体实现和规范（抽象方法）都有
   3. 接口：**只有规范**，实现约束和实现分离
2. 关键词：`interface`
3. 定义的是一组规则
4. 接口中的所有定义都是抽象的`public abstract`
   1. 类 可以实现接口`implements`接口
   2. 实现了接口中的类，就需要重写接口中的所有方法
   3. 可以通过接口实现多继承
   4. 接口中定义的属性是静态常量
   5. 接口不能被实例化（接口里没有构造方法）
5. **Lambda表达式**
	1. 匿名方法
	2. 书写方法：参数列表和方法体之间的符号是->
		```Java
		(参数列表)->{
			方法体;
		}
		``` 
	3. 必须有特殊的上下文，编译器才能推断出Lambda表达式是哪个方法，Lambda表达式的值就是方法的入口地址


## 十二、内部类

1. 套娃
2. new：通过外部类来new内部类
3. 可以获得外部类的私有属性

> 一个java类里可以有多个`class`，但只能有一个`public class`

- **匿名内部类**
	- 用来简化开发
	- 前提条件：
		- 必须继承**一个**父类或实现**一个**接口 
	- 系统底层为匿名内部类分配的名字：public类名+$01 
	- 外部其他类不能访问匿名内部类
		- 默认遵循就近原则，访问外部类的成员可以使用`外部类名.this.成员`
	- 匿名内部类可以当作实参直接传递
![](https://s2.loli.net/2022/04/27/8Q4pjns3iDaH9uh.png)



## 对象的组合
1. 组合和复用
	1. 对象a组合了对象b，对象a就可以委托对象b调用其方法
	2. 特点
		1. 当前对象只能委托所包含的对象调用其方法，即当前对象对所包含的方法的细节是一无所知的
		2. 当前对象随时可以更换所包含的对象，即对象与所包含的对象属于**弱耦合关系**
>完全解耦是尽最大程度降低类与类之间的耦合度，使程序具有很好的扩展性，便于修改  
耦合：类和类、模块和模块之间存在依赖关系，如果修改了某个实现就需要改一堆已经编写好的代码，这就是代码耦合度较高。/分层、注入、面向接口编程都是解耦的方式。
2. 类的关联关系和以来关系的UML图
	1. 关联关系（使用实线箭头连接）
		1. 如果**A类的成员变量是用B类声明的对象**，则A和B的关系是**关联关系**(则称A类对象关联于B类对象或A类的对象**组合**了B类的对象)
	2. 依赖关系（使用虚线箭头连接）
		1. 如果A类中某个**方法的参数使用B类声明的对象**或**某个方法返回的数据类型是B类对象**，则A与B的关系是**依赖关系**(称A依赖于B)


## var局部变量
- 使用var声明局部变量时，必须显式的指定初值（不可以是null），编译器会自动推断出变量的类型
- 方法的参数和方法的返回不能用var来声明

## 对象的上转型对象
- 即使用子类的构造方法构造一个父类的对象
- 特点
	- 不能访问新增的成员变量，不能调用子类新增的方法
	- 可以访问子类继承的成员变量
	- 可以对用子类继承的方法或子类重写的实例方法
- 可以将对象的上转型对象再强制转换为一个**子类对象**

## 垃圾回收机制
- 标记——清扫：
	1. 遍历所有的引用，找出所有存活的对象
	2. 每找到一个存活的对象，则对其进行标记（此过程不会回收任何对象）
	3. 标记空间全部完成后，才进行清理
	- 剩余的空间不连续，需要连续的空间则需要重新整理
- 停止——复制：
	- 清理动作发生时，程序将被暂停

- JVM会自动跟踪“标记清扫”的效果，如果堆空间出现许多碎片，则切换至“停止复制”