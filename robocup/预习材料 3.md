# 预习材料 3

# 小结一下上次培训内容

为什么要强调一个函数纯还是不纯呢？

因为纯的函数有一个非常好的性质 —— **引用透明**！而对于一个纯的系统，我们可以使用**代换模型**对其求值。代换模型是简单的求值模型。

数学表达式的化简，就是使用代换模型对表达式求值的一个例子。注意：我们不管先计算表达式的哪一部分，最后得到的结果都是一样的。由此我们可以窥见纯与不纯的系统的区别所在。

![img](https://cdn.nlark.com/yuque/__latex/e5b069e9c5bcc313419f075a480a27ab.svg)

**纯的递归**可以类比数学中的**递推关系的定义**和**数学归纳法**

- 归纳假设
- 归纳奠基

- 归纳递推
- 结论

纯的递归可以使用代换模型求值，如

![img](https://cdn.nlark.com/yuque/__latex/40c2cc7b0098a95f6292bfbd9331cbaf.svg)

> 你可能会问：为什么不把前面 4 x 3 x... 那一串算出来？因为每次计算我们只能选择计算一部分，不能同时对两部分进行计算。上面的模型中，我们选择的是计算 fact(x)。

使用代换模型对纯的递归表达式求值时，**当前表达式的长度**可作为计算过程所需空间大小的测度。

计算过程中，**表达式长度可能增长**，可能不变。

上面计算阶乘的过程中，每计算一次，表达式长度增长 1（常数）。称这样表达式长度线性增长的递归为**线性递归**。

阶乘也可以这样计算：

![img](https://cdn.nlark.com/yuque/__latex/ea6a3f92bcb6a79eb79dc24894d180d7.svg)

计算过程中表达式长度始终为一定值。称这样**表达式长度(占用内存)不增长的递归为尾递归**。

> 上面对递归的分析使用的求值模型都是**代换模型**，要求递归必须是纯的。如果递归不是纯的，我们则需要使用复杂的多的**带状态的求值模型**来分析（网上大部分讲尾递归的文章就是）。

可以证明，**所有的循环都可以被等价地改写为尾递归，反之亦然**。（Scala、Racket 等多范式语言中的循环实际上就是用尾递归实现的）

函数式编程的核心思想就是**构造一个从输入到输出的纯函数**。这个函数通常是由若干个小函数组合而成的，柯里化、匿名函数、高阶函数等都是用来组合函数的有用工具。为保证整个系统是纯的，我们**不能引入变量**（**常量是可以的**）。因此，不能使用过程式编程中我们熟悉的循环，因为循环必须要有变量，而是使用和循环等价的递归。能将递归改写为尾递归是最好的，因为尾递归占用的空间是常数，不会随着计算的进行而增加。

# 循环不变式

## 快速排序中的两种划分算法

[快速排序](https://zhuanlan.zhihu.com/p/340520050)

# 面向对象编程

## 对象 = 属性（数值） + 行为

对象（Object）属性（Attribute）行为（action）

![img](https://cdn.nlark.com/yuque/0/2021/png/1937915/1637050428246-b5885651-ef93-4564-a7ae-d56dfcb0e4a7.png)

## 类 —— 创建对象的模板

类（Class）

实例（Instance）



## 抽象类 —— 对属性和行为的抽象



## 接口 —— 仅对行为的抽象

接口（Interface）

1. 能对对象进行的操作



# 泛型

[泛型和元编程的模型](https://zhuanlan.zhihu.com/p/287965990)

## 装箱

## 单态化

# 多态

## 派发

### 静态派发

[说说C++的Concept](https://zhuanlan.zhihu.com/p/23290464)

### 动态派发

# 编译到可执行文件 & 库

## 库

一些不用编译就能使用的函数打包后就得到了一个库。一个库的头文件可以类比为这个库的说明书，指明了库里面有那些函数是可用的，应该怎么用（参数是什么，返回值是什么）。

之所以不用编译就能用，因为预先已经编译过了。因此生成一个库的方法也很简单，用编译器编译就好了。